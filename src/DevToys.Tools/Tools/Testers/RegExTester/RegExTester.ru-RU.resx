<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Инструмент проверки регулярных выражений</value>
  </data>
  <data name="AllMatches" xml:space="preserve">
    <value>Все совпадения</value>
  </data>
  <data name="AllMatchesDescription" xml:space="preserve">
    <value>Найти все совпадения в тексте или остановить после первого совпадения.</value>
  </data>
  <data name="CheatSheetAlternation" xml:space="preserve">
    <value>Чередование</value>
  </data>
  <data name="CheatSheetAlternationDetails" xml:space="preserve">
    <value>Действует как логическое ИЛИ. Соответствует выражению до или после |.
Он может работать внутри группы или целым выражением. Шаблоны будут протестированы по порядку.</value>
  </data>
  <data name="CheatSheetAnyCharacter" xml:space="preserve">
    <value>Любой символ, за исключением новой строки</value>
  </data>
  <data name="CheatSheetAnyCharacterDetails" xml:space="preserve">
    <value>Совпадает с любым символом, кроме новой строки. Эквивалент [^\n\r].</value>
  </data>
  <data name="CheatSheetAtomicGroup" xml:space="preserve">
    <value>Атомная группа</value>
  </data>
  <data name="CheatSheetAtomicGroupDetails" xml:space="preserve">
    <value>Группа незахвата, которая сбрасывает обратные позиции отслеживания после совпадения.
Например, /(?&gt;ab|a)b/ будет совпадать с abb, но не ab потому что после совпадения параметра ab, атомарная группа предотвращает обратное отслеживание для повторения с вариантом.</value>
  </data>
  <data name="CheatSheetBeginning" xml:space="preserve">
    <value>Начало</value>
  </data>
  <data name="CheatSheetBeginningDetails" xml:space="preserve">
    <value>Соответствует началу строки или началу строки, если включен флаг мультилинейной (m). Это совпадает с позицией, а не с символом.</value>
  </data>
  <data name="CheatSheetBeginningOfString" xml:space="preserve">
    <value>Начало строки</value>
  </data>
  <data name="CheatSheetBeginningOfStringDetails" xml:space="preserve">
    <value>Соответствует началу строки. В отличие от ^, это не зависит от флага многострочной (m). Это совпадает с позицией, а не с символом.</value>
  </data>
  <data name="CheatSheetBell" xml:space="preserve">
    <value>Колокольчик</value>
  </data>
  <data name="CheatSheetBellDetails" xml:space="preserve">
    <value>Соответствует символу BELL (символ 7).</value>
  </data>
  <data name="CheatSheetBranchResetGroup" xml:space="preserve">
    <value>Группа сброса ветки</value>
  </data>
  <data name="CheatSheetBranchResetGroupDetails" xml:space="preserve">
    <value>Определите альтернативные группы, которые имеют одинаковые номера групп.
Например, в (?|(a)|(b)) обе группы (a и b) будут считаться группой №1.</value>
  </data>
  <data name="CheatSheetCaptureGroup" xml:space="preserve">
    <value>Группа захвата</value>
  </data>
  <data name="CheatSheetCaptureGroupDetails" xml:space="preserve">
    <value>Вставляет результаты указанной группы захвата. Например, $3 вставьте третью группу захвата.
Для этой функции есть несколько синтаксисов:

$1 \1 \{1}</value>
  </data>
  <data name="CheatSheetCapturingGroup" xml:space="preserve">
    <value>Захват группы</value>
  </data>
  <data name="CheatSheetCapturingGroupDetails" xml:space="preserve">
    <value>Группирует несколько токенов вместе и создает группу захватов для извлечения подстрок или использования обратной ссылки.</value>
  </data>
  <data name="CheatSheetCarriageReturn" xml:space="preserve">
    <value>Возврат каретки</value>
  </data>
  <data name="CheatSheetCarriageReturnDetails" xml:space="preserve">
    <value>Совпадает с символом CARRIAGE RETURN (символ код 13).</value>
  </data>
  <data name="CheatSheetCategoryAnchors" xml:space="preserve">
    <value>Якоря</value>
  </data>
  <data name="CheatSheetCategoryCharacterClasses" xml:space="preserve">
    <value>Классы символов</value>
  </data>
  <data name="CheatSheetCategoryEscapedCharacters" xml:space="preserve">
    <value>Экранированные символы</value>
  </data>
  <data name="CheatSheetCategoryGroupsReferences" xml:space="preserve">
    <value>Группы и ссылки</value>
  </data>
  <data name="CheatSheetCategoryLookaround" xml:space="preserve">
    <value>Осмотреться</value>
  </data>
  <data name="CheatSheetCategoryQuantifiersAlternation" xml:space="preserve">
    <value>Кванторы и чередование</value>
  </data>
  <data name="CheatSheetCategorySpecial" xml:space="preserve">
    <value>Особый</value>
  </data>
  <data name="CheatSheetCategorySubstitution" xml:space="preserve">
    <value>Замена</value>
  </data>
  <data name="CheatSheetCharacterRange" xml:space="preserve">
    <value>Диапазон символов</value>
  </data>
  <data name="CheatSheetCharacterRangeDetails" xml:space="preserve">
    <value>Соответствует символу, имеющему символьный код между двумя указанными символами включительно.</value>
  </data>
  <data name="CheatSheetCharacterSet" xml:space="preserve">
    <value>Один символ A, b или c</value>
  </data>
  <data name="CheatSheetCharacterSetDetails" xml:space="preserve">
    <value>Совпадает с символом A, b или c</value>
  </data>
  <data name="CheatSheetComment" xml:space="preserve">
    <value>Комментарий</value>
  </data>
  <data name="CheatSheetCommentDetails" xml:space="preserve">
    <value>Позволяет вставить комментарий в выражение, которое игнорируется при поиске совпадения.</value>
  </data>
  <data name="CheatSheetConditional" xml:space="preserve">
    <value>Условие</value>
  </data>
  <data name="CheatSheetConditionalDetails" xml:space="preserve">
    <value>Условно соответствует одному из двух параметров, основанных на том, соответствует ли внешний вид.
Например, /(?(?(?=a)ab|.. / будет соответствовать ab и zx, но не ax, потому что если первый символ соответствует условию, то он вычисляет шаблон ab.

В качестве условия может использоваться любой внешний вид. Следующий взгляд начнется в начале условия, после чего начнется его поиск.</value>
  </data>
  <data name="CheatSheetControlCharacterEscape" xml:space="preserve">
    <value>Наличие контрольного символа</value>
  </data>
  <data name="CheatSheetControlCharacterEscapeDetails" xml:space="preserve">
    <value>Управляющий символ свернут в виде \cZ. Он может варьироваться от \cA (SOH, char code 1) до \cZ (SUB, char code 26).</value>
  </data>
  <data name="CheatSheetDefine" xml:space="preserve">
    <value>Определить</value>
  </data>
  <data name="CheatSheetDefineDetails" xml:space="preserve">
    <value>Используется для определения именованных групп для использования в качестве подпроцедур без их включения в матч.
Например, /A(?(DEFINE)(? foo'Z)B\g'foo'/ будет соответствовать ABZ, потому что определяемая группа игнорируется в матче, за исключением определения подпроцедуры фото, на которую ссылается \g'foo'.</value>
  </data>
  <data name="CheatSheetDescription" xml:space="preserve">
    <value>Описание</value>
  </data>
  <data name="CheatSheetDigit" xml:space="preserve">
    <value>Цифровой</value>
  </data>
  <data name="CheatSheetDigitDetails" xml:space="preserve">
    <value>Соответствует любому символу (0-9). Эквивалент [0-9].</value>
  </data>
  <data name="CheatSheetEnd" xml:space="preserve">
    <value>Конец</value>
  </data>
  <data name="CheatSheetEndDetails" xml:space="preserve">
    <value>Соответствует концу строки или концу строки, если включен флаг мультилинейной (m). Это совпадает с позицией, а не с символом.</value>
  </data>
  <data name="CheatSheetEndOfString" xml:space="preserve">
    <value>Конец строки</value>
  </data>
  <data name="CheatSheetEndOfStringDetails" xml:space="preserve">
    <value>Matches the end of the string. Unlike $, this is unaffected by the multiline flag (m). This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetEsc" xml:space="preserve">
    <value>Esc</value>
  </data>
  <data name="CheatSheetEscapedCharacters" xml:space="preserve">
    <value>Escaped characters</value>
  </data>
  <data name="CheatSheetEscapedCharactersDetails" xml:space="preserve">
    <value>For convenience, these escaped characters are supported in the Replace string in RegExr: \n, \r, \t, \\, and unicode escapes \uFFFF. This may vary in your deploy environment.</value>
  </data>
  <data name="CheatSheetEscapeSequence" xml:space="preserve">
    <value>Escape sequence</value>
  </data>
  <data name="CheatSheetEscapeSequenceDetails" xml:space="preserve">
    <value>All characters between the \Q and the \E are interpreted as a literal string. If \E is omitted, it continues to the end of the expression. For example, the expression /\Q(?.)\E/ will match the string (?.).</value>
  </data>
  <data name="CheatSheetEscDetails" xml:space="preserve">
    <value>Matches a ESC character (char code 27).</value>
  </data>
  <data name="CheatSheetFormFeed" xml:space="preserve">
    <value>Form feed</value>
  </data>
  <data name="CheatSheetFormFeedDetails" xml:space="preserve">
    <value>Matches a FORM FEED character (char code 12).</value>
  </data>
  <data name="CheatSheetGroupConditional" xml:space="preserve">
    <value>Group conditional</value>
  </data>
  <data name="CheatSheetGroupConditionalDetails" xml:space="preserve">
    <value>Conditionally matches one of two options based on whether group 'undefined' matched.
For example, /(z)?(?(1)a|b)/ will match za because the first capture group matches z successfully, which causes the conditional to match the first option a.

The same pattern will also match b on its own, because group 1 doesn't match, so it instead tries to match the second option b.

You can reference a group by name, number, or relative position (ex. -1).</value>
  </data>
  <data name="CheatSheetHexadecimalEscape" xml:space="preserve">
    <value>Hexadecimal escape</value>
  </data>
  <data name="CheatSheetHexadecimalEscapeDetails" xml:space="preserve">
    <value>Hexadecimal escaped character in the form \xFF.</value>
  </data>
  <data name="CheatSheetHorizontalWhitespace" xml:space="preserve">
    <value>Horizontal whitespace</value>
  </data>
  <data name="CheatSheetHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Matches any horizontal whitespace character (spaces, tabs).</value>
  </data>
  <data name="CheatSheetKeepOut" xml:space="preserve">
    <value>Keep out</value>
  </data>
  <data name="CheatSheetKeepOutDetails" xml:space="preserve">
    <value>Keep text matched so far out of the returned match, essentially discarding the match up to this point.For example /o\Kbar/ will match bar within the string foobar</value>
  </data>
  <data name="CheatSheetLazy" xml:space="preserve">
    <value>Lazy</value>
  </data>
  <data name="CheatSheetLazyDetails" xml:space="preserve">
    <value>Makes the preceding quantifier lazy, causing it to match as few characters as possible. By default, quantifiers are greedy, and will match as many characters as possible.
This behaviour is reversed by the ungreedy (U) flag/modifier.</value>
  </data>
  <data name="CheatSheetLineBreak" xml:space="preserve">
    <value>Line break</value>
  </data>
  <data name="CheatSheetLineBreakDetails" xml:space="preserve">
    <value>Matches any line break character, including the CRLF pair, and CR / LF individually.</value>
  </data>
  <data name="CheatSheetLineFeed" xml:space="preserve">
    <value>Line feed</value>
  </data>
  <data name="CheatSheetLineFeedDetails" xml:space="preserve">
    <value>Matches a LINE FEED character (char code 10).</value>
  </data>
  <data name="CheatSheetMatch" xml:space="preserve">
    <value>Match</value>
  </data>
  <data name="CheatSheetMatchAny" xml:space="preserve">
    <value>Match any</value>
  </data>
  <data name="CheatSheetMatchAnyDetails" xml:space="preserve">
    <value>A character set that can be used to match any character, including line breaks, without the dotall flag (s).</value>
  </data>
  <data name="CheatSheetMatchDetails" xml:space="preserve">
    <value>Inserts the matched text.
There are multiple syntaxes for this feature:

$0 \0 \{0}</value>
  </data>
  <data name="CheatSheetModeModifier" xml:space="preserve">
    <value>Mode modifier</value>
  </data>
  <data name="CheatSheetModeModifierDetails" xml:space="preserve">
    <value>Enables or disables modes for the remainder of the expression.Matching modes generally map to expression flags. For example (?i) would enable case insensitivity for the remainder of the expression.
Multiple modifiers can be specified, and any modifiers that follow - are disabled. For example (?im-s) would enable case insensitivity &amp; multiline modes, and disable dotall.

Supported modifiers are: i - case insensitive, s - dotall, m - multiline, x - free spacing, J - allow duplicate names, U - ungreedy.</value>
  </data>
  <data name="CheatSheetNamedCapturingGroup" xml:space="preserve">
    <value>Named capturing group</value>
  </data>
  <data name="CheatSheetNamedCapturingGroupDetails" xml:space="preserve">
    <value>Creates a capturing group that can be referenced via the specified name.
There are multiple syntaxes for this feature:

(?'name'ABC) (?P&lt;name&gt;ABC) (?&lt;name&gt;ABC)</value>
  </data>
  <data name="CheatSheetNamedReference" xml:space="preserve">
    <value>Named reference</value>
  </data>
  <data name="CheatSheetNamedReferenceDetails" xml:space="preserve">
    <value>Matches the results of a named capture group.
There are multiple syntaxes for this feature:

\k'name' \k&lt;name&gt; \k{name} \g{name} (?P=name)</value>
  </data>
  <data name="CheatSheetNamedSubroutine" xml:space="preserve">
    <value>Named subroutine</value>
  </data>
  <data name="CheatSheetNamedSubroutineDetails" xml:space="preserve">
    <value>Matches the expression in a capture group. Compare this to a reference, that matches the result.
There are multiple syntaxes for this feature: \g&lt;name&gt; \g'name' (?&amp;name) (?P&gt;name).</value>
  </data>
  <data name="CheatSheetNegatedCharacterSet" xml:space="preserve">
    <value>A character except A, b or c</value>
  </data>
  <data name="CheatSheetNegatedCharacterSetDetails" xml:space="preserve">
    <value>Match any character that is not A, b or c.</value>
  </data>
  <data name="CheatSheetNegativeLookahead" xml:space="preserve">
    <value>Negative lookahead</value>
  </data>
  <data name="CheatSheetNegativeLookaheadDetails" xml:space="preserve">
    <value>Specifies a group that can not match after the main expression (if it matches, the result is discarded).</value>
  </data>
  <data name="CheatSheetNegativeLookbehind" xml:space="preserve">
    <value>Negative lookbehind</value>
  </data>
  <data name="CheatSheetNegativeLookbehindDetails" xml:space="preserve">
    <value>Specifies a group that can not match before the main expression (if it matches, the result is discarded).</value>
  </data>
  <data name="CheatSheetNonCapturingGroup" xml:space="preserve">
    <value>Non-capturing group</value>
  </data>
  <data name="CheatSheetNonCapturingGroupDetails" xml:space="preserve">
    <value>Groups multiple tokens together without creating a capture group.</value>
  </data>
  <data name="CheatSheetNotDigit" xml:space="preserve">
    <value>Not digit</value>
  </data>
  <data name="CheatSheetNotDigitDetails" xml:space="preserve">
    <value>Matches any character that is not a digit character (0-9). Equivalent to [^0-9].</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespace" xml:space="preserve">
    <value>Not horizontal whitespace</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Matches any character that is not a horizontal whitespace character (spaces, tabs).</value>
  </data>
  <data name="CheatSheetNotLineBreak" xml:space="preserve">
    <value>Not line break</value>
  </data>
  <data name="CheatSheetNotLineBreakDetails" xml:space="preserve">
    <value>Matches any character that is not a line break. Similar to dot (.) but is unaffected by the dotall flag (s).</value>
  </data>
  <data name="CheatSheetNotUnicodeCategory" xml:space="preserve">
    <value>Not unicode category</value>
  </data>
  <data name="CheatSheetNotUnicodeCategoryDetails" xml:space="preserve">
    <value>Совпадает с любым символом, который не относится к указанной категории unicode.</value>
  </data>
  <data name="CheatSheetNotUnicodeScript" xml:space="preserve">
    <value>Не в unicode скрипте</value>
  </data>
  <data name="CheatSheetNotUnicodeScriptDetails" xml:space="preserve">
    <value>Совпадает с любым символом, который не относится к указанной категории unicode.</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespace" xml:space="preserve">
    <value>Не вертикальные пробелы</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespaceDetails" xml:space="preserve">
    <value>Совпадает с любым символом, который не является вертикальным пробелом (разрывом строки).</value>
  </data>
  <data name="CheatSheetNotWhitespace" xml:space="preserve">
    <value>Нет пробела</value>
  </data>
  <data name="CheatSheetNotWhitespaceDetails" xml:space="preserve">
    <value>Совпадает с любым символом, который не является вертикальным пробелом (разрывом строки).</value>
  </data>
  <data name="CheatSheetNotWord" xml:space="preserve">
    <value>Не слово</value>
  </data>
  <data name="CheatSheetNotWordBoundary" xml:space="preserve">
    <value>Нет границы слова</value>
  </data>
  <data name="CheatSheetNotWordBoundaryDetails" xml:space="preserve">
    <value>Соответствует любой позиции, не являющейся рамкой слова. Это совпадает с позицией, а не с символом.</value>
  </data>
  <data name="CheatSheetNotWordDetails" xml:space="preserve">
    <value>Соответствует любому символу, не являющему словом (буквенно-цифровым и подчеркиванием). Эквивалент [^A-Za-z0-9_]</value>
  </data>
  <data name="CheatSheetNull" xml:space="preserve">
    <value>Null</value>
  </data>
  <data name="CheatSheetNullDetails" xml:space="preserve">
    <value>Соответствует символу BELL (символ 0).</value>
  </data>
  <data name="CheatSheetNumericReference" xml:space="preserve">
    <value>Числовая ссылка</value>
  </data>
  <data name="CheatSheetNumericReferenceDetails" xml:space="preserve">
    <value>Соответствует результатам группы захвата. Например, \1 соответствует результатам первой группы захвата, а \3 - третьей.
Для этой функции существует несколько синтаксических вариантов: \1 \g1 \g{1}.

Последние синтаксисы поддерживают относительные значения, которым предшествуют + или -. Например, \g-1 будет соответствовать группе, предшествующей ссылке.</value>
  </data>
  <data name="CheatSheetNumericSubroutine" xml:space="preserve">
    <value>Числовая подпрограмма</value>
  </data>
  <data name="CheatSheetNumericSubroutineDetails" xml:space="preserve">
    <value>Соответствует выражению в группе захвата. Сравните это со ссылкой, которая соответствует результату. Например, /(a|b)\g'1'/ может соответствовать ab, поскольку выражение a|b вычисляется повторно.
Для этой функции существует несколько синтаксисов: \g&lt;1&gt; \g'1' (?1).

Также поддерживаются относительные значения, которым предшествуют + или -. Например, \g&lt;-1&gt; будет соответствовать группе, предшествующей ссылке.</value>
  </data>
  <data name="CheatSheetOctalEscape" xml:space="preserve">
    <value>Восьмеричный побег</value>
  </data>
  <data name="CheatSheetOctalEscapeDetails" xml:space="preserve">
    <value>Октальный экранированный символ в виде \000. Значение должно быть меньше 255 (\377).
также поддерживается синтаксис \o{FFF}.</value>
  </data>
  <data name="CheatSheetOptional" xml:space="preserve">
    <value>Необязательно</value>
  </data>
  <data name="CheatSheetOptionalDetails" xml:space="preserve">
    <value>Соответствия 0 или 1 из предшествующего токена, эффективно делая его необязательным.</value>
  </data>
  <data name="CheatSheetPlus" xml:space="preserve">
    <value>Плюс</value>
  </data>
  <data name="CheatSheetPlusDetails" xml:space="preserve">
    <value>Совпадает с 1 или более из предыдущего токена.</value>
  </data>
  <data name="CheatSheetPositiveLookahead" xml:space="preserve">
    <value>Положительный взгляд</value>
  </data>
  <data name="CheatSheetPositiveLookaheadDetails" xml:space="preserve">
    <value>Соответствует группе после основного выражения, не включив его в результат.</value>
  </data>
  <data name="CheatSheetPositiveLookbehind" xml:space="preserve">
    <value>Положительный взгляд</value>
  </data>
  <data name="CheatSheetPositiveLookbehindDetails" xml:space="preserve">
    <value>Соответствует группе после основного выражения, не включив его в результат.</value>
  </data>
  <data name="CheatSheetPossessive" xml:space="preserve">
    <value>Притяжательный</value>
  </data>
  <data name="CheatSheetPossessiveDetails" xml:space="preserve">
    <value>Делает предыдущее владение количественным. Он будет совпадать как можно большему количеству символов и не будет отпускать их в соответствие с последующими токенами.
Например, /.*a/ будет совпадать с aaa, но /. +a/ не будет, потому что повторяющаяся точка будет совпадать и не отпускать последний символ для совпадения.</value>
  </data>
  <data name="CheatSheetPreviousMatchEnd" xml:space="preserve">
    <value>Конец предыдущего матча</value>
  </data>
  <data name="CheatSheetPreviousMatchEndDetails" xml:space="preserve">
    <value>Соответствует конечной позиции предыдущего матча. Это совпадает с позицией, а не с символом.</value>
  </data>
  <data name="CheatSheetQuantifier" xml:space="preserve">
    <value>Кванторы</value>
  </data>
  <data name="CheatSheetQuantifierDetails" xml:space="preserve">
    <value>Соответствует указанному количеству токенов. {1,3} будет совпадать с 1 до 3. {3} будет совпадать ровно с 3. {3,} будет совпадать с 3 или более.</value>
  </data>
  <data name="CheatSheetRecursion" xml:space="preserve">
    <value>Рекурсия</value>
  </data>
  <data name="CheatSheetRecursionDetails" xml:space="preserve">
    <value>Попытки снова совпадать с полным выражением в текущей позиции.
Например, /a(?R)? / будет совпадать с любым номером с таким же номером z: полный текст az или aaazzzz, но не азот.

Есть несколько синтаксисов для этой функции:

(?R) (?0) \g&lt;0&gt; \g'0'</value>
  </data>
  <data name="CheatSheetReservedCharacters" xml:space="preserve">
    <value>Зарезервированные символы</value>
  </data>
  <data name="CheatSheetReservedCharactersDetails" xml:space="preserve">
    <value>Следующие символы имеют особое значение, и перед ними должен быть знак \ (обратная косая косая черта), чтобы представить буквенный символ:
+*?^$\. ]{}()|/

Внутри набора символов нужно экранировать только \, -, и ].</value>
  </data>
  <data name="CheatSheetStar" xml:space="preserve">
    <value>В избранное</value>
  </data>
  <data name="CheatSheetStarDetails" xml:space="preserve">
    <value>Совпадает с 0 или более из предыдущего токена.</value>
  </data>
  <data name="CheatSheetStrictEndOfString" xml:space="preserve">
    <value>Строгий конец строки</value>
  </data>
  <data name="CheatSheetStrictEndOfStringDetails" xml:space="preserve">
    <value>Соответствует концу строки. В отличие от $ или \Z, это не позволяет завершать новую строку. Это не зависит от флага многострочного (m). Это совпадает с позицией, а не с символом.</value>
  </data>
  <data name="CheatSheetSyntax" xml:space="preserve">
    <value>Синтаксис</value>
  </data>
  <data name="CheatSheetTab" xml:space="preserve">
    <value>Вкладка</value>
  </data>
  <data name="CheatSheetTabDetails" xml:space="preserve">
    <value>Соответствует символу TAB (символ 9).</value>
  </data>
  <data name="CheatSheetTitle" xml:space="preserve">
    <value>Шпаргалка</value>
  </data>
  <data name="CheatSheetUnicodeCategory" xml:space="preserve">
    <value>Категория Unicode</value>
  </data>
  <data name="CheatSheetUnicodeCategoryDetails" xml:space="preserve">
    <value>Соответствует символу в указанной категории unicode. Например, \p{Ll} будет соответствовать любой строчной букве.</value>
  </data>
  <data name="CheatSheetUnicodeEscape" xml:space="preserve">
    <value>Выход из Unicode</value>
  </data>
  <data name="CheatSheetUnicodeEscapeDetails" xml:space="preserve">
    <value>Unicode экранировал символ в виде \x{FF}.</value>
  </data>
  <data name="CheatSheetUnicodeGrapheme" xml:space="preserve">
    <value>График Unicode</value>
  </data>
  <data name="CheatSheetUnicodeGraphemeDetails" xml:space="preserve">
    <value>Matches any single unicode grapheme (ie. character). This includes line breaks (regardless of the dotall mode) and graphemes encoded as multiple code points.</value>
  </data>
  <data name="CheatSheetUnicodeScript" xml:space="preserve">
    <value>Unicode script</value>
  </data>
  <data name="CheatSheetUnicodeScriptDetails" xml:space="preserve">
    <value>Matches any character in the specified unicode script. For example, \p{Arabic} will match characters in the Arabic script.</value>
  </data>
  <data name="CheatSheetVerticalWhitespace" xml:space="preserve">
    <value>Vertical whitespace</value>
  </data>
  <data name="CheatSheetVerticalWhitespaceDetails" xml:space="preserve">
    <value>Matches any vertical whitespace character (line breaks).</value>
  </data>
  <data name="CheatSheetWhitespace" xml:space="preserve">
    <value>Whitespace</value>
  </data>
  <data name="CheatSheetWhitespaceDetails" xml:space="preserve">
    <value>Matches any whitespace character (spaces, tabs, line breaks).</value>
  </data>
  <data name="CheatSheetWord" xml:space="preserve">
    <value>Word</value>
  </data>
  <data name="CheatSheetWordBoundary" xml:space="preserve">
    <value>Word boundary</value>
  </data>
  <data name="CheatSheetWordBoundaryDetails" xml:space="preserve">
    <value>Matches a word boundary position between a word character and non-word character or position (start / end of string). See the word character class (w) for more info.</value>
  </data>
  <data name="CheatSheetWordDetails" xml:space="preserve">
    <value>Matches any word character (alphanumeric &amp; underscore). Only matches low-ascii characters (no accented or non-roman characters). Equivalent to [A-Za-z0-9_]</value>
  </data>
  <data name="Configuration" xml:space="preserve">
    <value>Configuration</value>
  </data>
  <data name="CultureInvariant" xml:space="preserve">
    <value>Culture Invariant</value>
  </data>
  <data name="CultureInvariantDescription" xml:space="preserve">
    <value>Specifies that cultural differences in language is ignored.</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Validate and test regular expressions</value>
  </data>
  <data name="EcmaScript" xml:space="preserve">
    <value>ECMA Script</value>
  </data>
  <data name="EcmaScriptDescription" xml:space="preserve">
    <value>Enables ECMAScript-compliant behavior for the expression. This value can be used only in conjunction with the Culture Invariant, Ignore Case and Multiline options.</value>
  </data>
  <data name="IgnoreCase" xml:space="preserve">
    <value>Ignore Case</value>
  </data>
  <data name="IgnoreCaseDescription" xml:space="preserve">
    <value>Specifies case-insensitive matching.</value>
  </data>
  <data name="IgnoreWhitespace" xml:space="preserve">
    <value>Ignore Whitespace</value>
  </data>
  <data name="IgnoreWhitespaceDescription" xml:space="preserve">
    <value>Eliminates unescaped white space from the pattern and enables comments marked with #. However, this value does not affect or eliminate white space in character classes, numeric quantifiers, or tokens that mark the beginning of individual regular expression language elements.</value>
  </data>
  <data name="LongDisplayTitle" xml:space="preserve">
    <value>Regular Expression Tester</value>
  </data>
  <data name="MatchGroupPrefix" xml:space="preserve">
    <value>Group</value>
  </data>
  <data name="MatchInformation" xml:space="preserve">
    <value>Match information</value>
  </data>
  <data name="MatchLocation" xml:space="preserve">
    <value>Location</value>
  </data>
  <data name="MatchName" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="MatchNamePrefix" xml:space="preserve">
    <value>Match</value>
  </data>
  <data name="MatchValue" xml:space="preserve">
    <value>Значение</value>
  </data>
  <data name="Multiline" xml:space="preserve">
    <value>Многострочный</value>
  </data>
  <data name="MultilineDescription" xml:space="preserve">
    <value>Changes the meaning of ^ and $ so they match at the beginning and end, respectively, of any line, and not just the beginning and end of the entire string.</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>Опции</value>
  </data>
  <data name="RegularExpression" xml:space="preserve">
    <value>Regular expression</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>Right To Left</value>
  </data>
  <data name="RightToLeftDescription" xml:space="preserve">
    <value>Specifies that the search will be from right to left instead of from left to right.</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value>regular expression</value>
  </data>
  <data name="ShortDisplayTitle" xml:space="preserve">
    <value>RegEx</value>
  </data>
  <data name="Singleline" xml:space="preserve">
    <value>Singleline</value>
  </data>
  <data name="SinglelineDescription" xml:space="preserve">
    <value>Changes the meaning of the dot (.) so it matches every character (instead of every character except \n).</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>Text</value>
  </data>
</root>