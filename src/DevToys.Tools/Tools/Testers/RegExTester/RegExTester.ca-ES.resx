<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Eina de proves d'expressions regulars</value>
  </data>
  <data name="AllMatches" xml:space="preserve">
    <value>Totes les coincidències</value>
  </data>
  <data name="AllMatchesDescription" xml:space="preserve">
    <value>Cerqueu totes les coincidències al text o atureu-vos després de la primera coincidència.</value>
  </data>
  <data name="CheatSheetAlternation" xml:space="preserve">
    <value>Alternança</value>
  </data>
  <data name="CheatSheetAlternationDetails" xml:space="preserve">
    <value>Actua com un OR booleà. Coincideix amb l'expressió abans o després de |.
Pot operar dins d'un grup, o sobre una expressió sencera. Els patrons es provaran en ordre.</value>
  </data>
  <data name="CheatSheetAnyCharacter" xml:space="preserve">
    <value>Qualsevol caràcter excepte una nova línia</value>
  </data>
  <data name="CheatSheetAnyCharacterDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter que no sigui nova línia. Equivalent a [^\n\r].</value>
  </data>
  <data name="CheatSheetAtomicGroup" xml:space="preserve">
    <value>Grup atòmic</value>
  </data>
  <data name="CheatSheetAtomicGroupDetails" xml:space="preserve">
    <value>Grup que no captura que descarta les posicions de marxa enrere un cop coincideixen.
Per exemple, /(?&gt;ab|a)b/ coincidirà amb abb però no amb ab perquè un cop l'opció ab ha coincidit, el grup atòmic impedeix fer marxa enrere per tornar a intentar-ho amb l'opció a.</value>
  </data>
  <data name="CheatSheetBeginning" xml:space="preserve">
    <value>Principi</value>
  </data>
  <data name="CheatSheetBeginningDetails" xml:space="preserve">
    <value>Coincideix amb l'inici de la cadena o amb l'inici d'una línia si la marca multilínia (m) està activada. Això coincideix amb una posició, no un caràcter.</value>
  </data>
  <data name="CheatSheetBeginningOfString" xml:space="preserve">
    <value>Principi de la cadena</value>
  </data>
  <data name="CheatSheetBeginningOfStringDetails" xml:space="preserve">
    <value>Coincideix amb l'inici de la cadena. A diferència de ^, això no es veu afectat per la marca multilínia (m). Això coincideix amb una posició, no un caràcter.</value>
  </data>
  <data name="CheatSheetBell" xml:space="preserve">
    <value>Campana</value>
  </data>
  <data name="CheatSheetBellDetails" xml:space="preserve">
    <value>Coincideix amb un caràcter BELL (codi de caràcters 7).</value>
  </data>
  <data name="CheatSheetBranchResetGroup" xml:space="preserve">
    <value>Grup de reinici de branca</value>
  </data>
  <data name="CheatSheetBranchResetGroupDetails" xml:space="preserve">
    <value>Defineix grups alternatius que comparteixen els mateixos números de grup.
Per exemple, a (?|(a)|(b)) ambdós grups (a i b) es comptarien com a grup #1.</value>
  </data>
  <data name="CheatSheetCaptureGroup" xml:space="preserve">
    <value>Captura un grup</value>
  </data>
  <data name="CheatSheetCaptureGroupDetails" xml:space="preserve">
    <value>Insereix els resultats del grup de captura especificat. Per exemple, $3 inseriria el tercer grup de captura.
Hi ha diverses sintaxis per a aquesta funció:

$1 \1 \{1}</value>
  </data>
  <data name="CheatSheetCapturingGroup" xml:space="preserve">
    <value>Capturant un grup</value>
  </data>
  <data name="CheatSheetCapturingGroupDetails" xml:space="preserve">
    <value>Agrupa diversos tokens i crea un grup de captura per extreure una subcadena o utilitzar una referència posterior.</value>
  </data>
  <data name="CheatSheetCarriageReturn" xml:space="preserve">
    <value>Retorn de carro</value>
  </data>
  <data name="CheatSheetCarriageReturnDetails" xml:space="preserve">
    <value>Coincideix amb un caràcter CARRIAGE RETURN (codi de caràcter 13).</value>
  </data>
  <data name="CheatSheetCategoryAnchors" xml:space="preserve">
    <value>Àncores</value>
  </data>
  <data name="CheatSheetCategoryCharacterClasses" xml:space="preserve">
    <value>Classes de caràcters</value>
  </data>
  <data name="CheatSheetCategoryEscapedCharacters" xml:space="preserve">
    <value>Caràcters escapats</value>
  </data>
  <data name="CheatSheetCategoryGroupsReferences" xml:space="preserve">
    <value>Grups i referències</value>
  </data>
  <data name="CheatSheetCategoryLookaround" xml:space="preserve">
    <value>Lookaround</value>
  </data>
  <data name="CheatSheetCategoryQuantifiersAlternation" xml:space="preserve">
    <value>Quantificadors i alternança</value>
  </data>
  <data name="CheatSheetCategorySpecial" xml:space="preserve">
    <value>Especial</value>
  </data>
  <data name="CheatSheetCategorySubstitution" xml:space="preserve">
    <value>Substitució</value>
  </data>
  <data name="CheatSheetCharacterRange" xml:space="preserve">
    <value>Rang de caràcters</value>
  </data>
  <data name="CheatSheetCharacterRangeDetails" xml:space="preserve">
    <value>Coincideix amb un caràcter amb un codi de caràcter entre els dos caràcters especificats inclosos.</value>
  </data>
  <data name="CheatSheetCharacterSet" xml:space="preserve">
    <value>Un sol caràcter de A, b o c</value>
  </data>
  <data name="CheatSheetCharacterSetDetails" xml:space="preserve">
    <value>Coincideix amb un caràcter A, b o c</value>
  </data>
  <data name="CheatSheetComment" xml:space="preserve">
    <value>Comentari</value>
  </data>
  <data name="CheatSheetCommentDetails" xml:space="preserve">
    <value>Permet inserir un comentari a l'expressió que s'ignora en trobar una coincidència.</value>
  </data>
  <data name="CheatSheetConditional" xml:space="preserve">
    <value>Condicional</value>
  </data>
  <data name="CheatSheetConditionalDetails" xml:space="preserve">
    <value>Coincideix condicionalment amb una de les dues opcions en funció de si coincideix amb lookaround.
Per exemple, /(?(?=a)ab|..)/ coincidirà amb ab i zx però no ax, perquè si el primer caràcter coincideix amb la condició a, avaluarà el patró ab.

Qualsevol lookaround es pot utilitzar com a condició. Un lookahead començarà la partida posterior a l'inici de la condició, un lookabehind l'iniciarà després.</value>
  </data>
  <data name="CheatSheetControlCharacterEscape" xml:space="preserve">
    <value>Controla l'escapada de caràcters</value>
  </data>
  <data name="CheatSheetControlCharacterEscapeDetails" xml:space="preserve">
    <value>Caràcter de control escapat amb la forma \cZ. Això pot anar des de \cA (SOH, codi de caràcters 1) fins a \cZ (SUB, codi de caràcters 26).</value>
  </data>
  <data name="CheatSheetDefine" xml:space="preserve">
    <value>Defineix</value>
  </data>
  <data name="CheatSheetDefineDetails" xml:space="preserve">
    <value>S'utilitza per definir grups amb nom per utilitzar-los com a subrutines sense incloure'ls a la coincidència.
Per exemple, /A(?(DEFINE)(?'foo'Z))B\g'foo'/ coincidirà amb ABZ, perquè el grup definit s'ignora a la coincidència excepte per definir la subrutina foo a la qual es fa referència més tard amb \ g'foo'.</value>
  </data>
  <data name="CheatSheetDescription" xml:space="preserve">
    <value>Descripció</value>
  </data>
  <data name="CheatSheetDigit" xml:space="preserve">
    <value>Dígit</value>
  </data>
  <data name="CheatSheetDigitDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter numèric (0-9). Equivalent a [0-9].</value>
  </data>
  <data name="CheatSheetEnd" xml:space="preserve">
    <value>Fi</value>
  </data>
  <data name="CheatSheetEndDetails" xml:space="preserve">
    <value>Coincideix amb el final de la cadena o el final d'una línia si la marca multilínia (m) està activada. Això coincideix amb una posició, no un caràcter.</value>
  </data>
  <data name="CheatSheetEndOfString" xml:space="preserve">
    <value>Final de la cadena</value>
  </data>
  <data name="CheatSheetEndOfStringDetails" xml:space="preserve">
    <value>Coincideix amb el final de la cadena. A diferència de $, això no es veu afectat per la marca multilínia (m). Això coincideix amb una posició, no un caràcter.</value>
  </data>
  <data name="CheatSheetEsc" xml:space="preserve">
    <value>Esc</value>
  </data>
  <data name="CheatSheetEscapedCharacters" xml:space="preserve">
    <value>Caràcters escapats</value>
  </data>
  <data name="CheatSheetEscapedCharactersDetails" xml:space="preserve">
    <value>Per conveniència, aquests caràcters d'escapada s'admeten a la cadena Reemplaça a RegExr: \n, \r, \t, \\, i els escapes Unicode \uFFFF. Això pot variar en el vostre entorn de desplegament.</value>
  </data>
  <data name="CheatSheetEscapeSequence" xml:space="preserve">
    <value>Seqüència d'escapada</value>
  </data>
  <data name="CheatSheetEscapeSequenceDetails" xml:space="preserve">
    <value>Tots els caràcters entre \Q i \E s'interpreten com una cadena literal. Si s'omet \E, continua fins al final de l'expressió. Per exemple, l'expressió /\Q(?.)\E/ coincidirà amb la cadena (?.).</value>
  </data>
  <data name="CheatSheetEscDetails" xml:space="preserve">
    <value>Coincideix amb un caràcter ESC (codi de caràcter 27).</value>
  </data>
  <data name="CheatSheetFormFeed" xml:space="preserve">
    <value>Form feed</value>
  </data>
  <data name="CheatSheetFormFeedDetails" xml:space="preserve">
    <value>Coincideix amb un caràcter FORM FEED (codi de caràcters 12).</value>
  </data>
  <data name="CheatSheetGroupConditional" xml:space="preserve">
    <value>Grup condicional</value>
  </data>
  <data name="CheatSheetGroupConditionalDetails" xml:space="preserve">
    <value>Coincideix condicionalment amb una de les dues opcions en funció de si el grup "indefinit" coincideix.
Per exemple, /(z)?(?(1)a|b)/ coincidirà amb za perquè el primer grup de captura coincideix amb z, cosa que fa que el condicional coincideixi amb la primera opció a.

El mateix patró també coincidirà amb b per si mateix, perquè el grup 1 no coincideix, de manera que, en canvi, intenta fer coincidir la segona opció b.

Pots fer referència a un grup per nom, número o posició relativa (p. ex. -1).</value>
  </data>
  <data name="CheatSheetHexadecimalEscape" xml:space="preserve">
    <value>Escapat hexadecimal</value>
  </data>
  <data name="CheatSheetHexadecimalEscapeDetails" xml:space="preserve">
    <value>Caràcter d'escapat hexadecimal en la forma \xFF.</value>
  </data>
  <data name="CheatSheetHorizontalWhitespace" xml:space="preserve">
    <value>Espai en blanc horitzontal</value>
  </data>
  <data name="CheatSheetHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter d'espai en blanc horitzontal (espais, tabuladors).</value>
  </data>
  <data name="CheatSheetKeepOut" xml:space="preserve">
    <value>Exclou</value>
  </data>
  <data name="CheatSheetKeepOutDetails" xml:space="preserve">
    <value>Manté el text coincident fins ara fora de la coincidència retornada, bàsicament descartant la coincidència fins a aquest punt. Per exemple, /o\Kbar/ coincidirà amb la barra dins de la barra de cadenes</value>
  </data>
  <data name="CheatSheetLazy" xml:space="preserve">
    <value>Mandrós</value>
  </data>
  <data name="CheatSheetLazyDetails" xml:space="preserve">
    <value>Fa que el quantificador anterior sigui mandrós i fa que coincideixi amb el mínim de caràcters possible. Per defecte, els quantificadors són cobdiciosos i coincidiran amb tants caràcters com sigui possible.
Aquest comportament s'inverteix amb la bandera/modificador ungreedy (U).</value>
  </data>
  <data name="CheatSheetLineBreak" xml:space="preserve">
    <value>Salt de línia</value>
  </data>
  <data name="CheatSheetLineBreakDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter de salt de línia, inclòs el parell CRLF, i CR/LF individualment.</value>
  </data>
  <data name="CheatSheetLineFeed" xml:space="preserve">
    <value>Line feed</value>
  </data>
  <data name="CheatSheetLineFeedDetails" xml:space="preserve">
    <value>Coincideix amb un caràcter LINE FEED (codi de caràcters 10).</value>
  </data>
  <data name="CheatSheetMatch" xml:space="preserve">
    <value>Coincideix</value>
  </data>
  <data name="CheatSheetMatchAny" xml:space="preserve">
    <value>Coincideix amb qualsevol</value>
  </data>
  <data name="CheatSheetMatchAnyDetails" xml:space="preserve">
    <value>Conjunt de caràcters que es poden utilitzar per fer coincidir qualsevol caràcter, inclosos els salts de línia, sense la marca dotall (s).</value>
  </data>
  <data name="CheatSheetMatchDetails" xml:space="preserve">
    <value>Insereix el text coincident.
Hi ha diverses sintaxis per a aquesta funció:

$0 \0 \{0}</value>
  </data>
  <data name="CheatSheetModeModifier" xml:space="preserve">
    <value>Modificador de mode</value>
  </data>
  <data name="CheatSheetModeModifierDetails" xml:space="preserve">
    <value>Activa o desactiva els modes per a la resta de l'expressió. Els modes de concordança generalment s'assignen als indicadors d'expressió. Per exemple (?i) activaria la insensibilitat a majúscules i minúscules per a la resta de l'expressió.
Es poden especificar diversos modificadors i tots els modificadors que segueixen estan desactivats. Per exemple (?im-s) activaria la insensibilitat a majúscules i minúscules &amp; modes multilínia i desactiveu dotall.

Els modificadors admesos són: i - que no distingeix entre majúscules i minúscules, s - dotall, m - multilínia, x - espai lliure, J - permeten noms duplicats, U - ungreedy.</value>
  </data>
  <data name="CheatSheetNamedCapturingGroup" xml:space="preserve">
    <value>Grup de captura anomenat</value>
  </data>
  <data name="CheatSheetNamedCapturingGroupDetails" xml:space="preserve">
    <value>Crea un grup de captura al qual es pot fer referència amb el nom especificat.
Hi ha diverses sintaxis per a aquesta funció:

(?'name'ABC) (?P&lt;name&gt;ABC) (?&lt;name&gt;ABC)</value>
  </data>
  <data name="CheatSheetNamedReference" xml:space="preserve">
    <value>Referència anomenada</value>
  </data>
  <data name="CheatSheetNamedReferenceDetails" xml:space="preserve">
    <value>Coincideix amb els resultats d'un grup de captura anomenat.
Hi ha diverses sintaxis per a aquesta funció:

\k'name' \k&lt;name&gt; \k{name} \g{name} (?P=name)</value>
  </data>
  <data name="CheatSheetNamedSubroutine" xml:space="preserve">
    <value>Subrutina anomenada</value>
  </data>
  <data name="CheatSheetNamedSubroutineDetails" xml:space="preserve">
    <value>Coincideix amb l'expressió en un grup de captura. Compareu-ho amb una referència que coincideixi amb el resultat.
Hi ha múltiples sintaxis per a aquesta funció: \g&lt;name&gt; \g'name' (?&amp;name) (?P&gt;name).</value>
  </data>
  <data name="CheatSheetNegatedCharacterSet" xml:space="preserve">
    <value>Un caràcter excepte A, b o c</value>
  </data>
  <data name="CheatSheetNegatedCharacterSetDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter que no sigui A, b o c.</value>
  </data>
  <data name="CheatSheetNegativeLookahead" xml:space="preserve">
    <value>Lookahead negativa</value>
  </data>
  <data name="CheatSheetNegativeLookaheadDetails" xml:space="preserve">
    <value>Especifica un grup que no pot coincidir després de l'expressió principal (si coincideix, el resultat es descarta).</value>
  </data>
  <data name="CheatSheetNegativeLookbehind" xml:space="preserve">
    <value>Lookbehind negativa</value>
  </data>
  <data name="CheatSheetNegativeLookbehindDetails" xml:space="preserve">
    <value>Especifica un grup que no pot coincidir abans de l'expressió principal (si coincideix, el resultat es descarta).</value>
  </data>
  <data name="CheatSheetNonCapturingGroup" xml:space="preserve">
    <value>Grup que no es captura</value>
  </data>
  <data name="CheatSheetNonCapturingGroupDetails" xml:space="preserve">
    <value>Agrupa diversos fitxes sense crear un grup de captura.</value>
  </data>
  <data name="CheatSheetNotDigit" xml:space="preserve">
    <value>No numèric</value>
  </data>
  <data name="CheatSheetNotDigitDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter que no sigui un caràcter numèric (0-9). Equivalent a [^0-9].</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespace" xml:space="preserve">
    <value>No espai en blanc horitzontal</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter que no sigui un caràcter d'espai en blanc horitzontal (espais, tabuladors).</value>
  </data>
  <data name="CheatSheetNotLineBreak" xml:space="preserve">
    <value>No salt de línia</value>
  </data>
  <data name="CheatSheetNotLineBreakDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter que no sigui un salt de línia. Semblant al punt (.) però no es veu afectat per la bandera dotall (s).</value>
  </data>
  <data name="CheatSheetNotUnicodeCategory" xml:space="preserve">
    <value>No categoria Unicode</value>
  </data>
  <data name="CheatSheetNotUnicodeCategoryDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter que no estigui a la categoria Unicode especificada.</value>
  </data>
  <data name="CheatSheetNotUnicodeScript" xml:space="preserve">
    <value>No script Unicode</value>
  </data>
  <data name="CheatSheetNotUnicodeScriptDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter que no estigui a l'script Unicode especificat.</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespace" xml:space="preserve">
    <value>No espais en blanc verticals</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespaceDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter que no sigui un caràcter d'espai en blanc vertical (salts de línia).</value>
  </data>
  <data name="CheatSheetNotWhitespace" xml:space="preserve">
    <value>No espais en blanc</value>
  </data>
  <data name="CheatSheetNotWhitespaceDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter que no sigui un caràcter d'espai en blanc (espais, tabulacions, salts de línia).</value>
  </data>
  <data name="CheatSheetNotWord" xml:space="preserve">
    <value>No paraula</value>
  </data>
  <data name="CheatSheetNotWordBoundary" xml:space="preserve">
    <value>Sense límit de paraula</value>
  </data>
  <data name="CheatSheetNotWordBoundaryDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol posició que no sigui un límit de paraula. Això coincideix amb una posició, no amb un personatge.</value>
  </data>
  <data name="CheatSheetNotWordDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter que no sigui un caràcter de paraula (alfanumèric i guió baix). Equivalent a [^A-Za-z0-9_]</value>
  </data>
  <data name="CheatSheetNull" xml:space="preserve">
    <value>Nul</value>
  </data>
  <data name="CheatSheetNullDetails" xml:space="preserve">
    <value>Coincideix amb un caràcter NULL (codi de caràcters 0).</value>
  </data>
  <data name="CheatSheetNumericReference" xml:space="preserve">
    <value>Referència numèrica</value>
  </data>
  <data name="CheatSheetNumericReferenceDetails" xml:space="preserve">
    <value>Coincideix amb els resultats d'un grup de captura. Per exemple, \1 coincideix amb els resultats del primer grup de captura &amp; \3 coincideix amb el tercer.
Hi ha múltiples sintaxis per a aquesta característica: \1 \g1 \g{1}.

Aquestes últimes sintaxis admeten valors relatius precedits de + o -. Per exemple, \g-1 coincidiria amb el grup que precedeix la referència.</value>
  </data>
  <data name="CheatSheetNumericSubroutine" xml:space="preserve">
    <value>Subrutina numèrica</value>
  </data>
  <data name="CheatSheetNumericSubroutineDetails" xml:space="preserve">
    <value>Coincideix amb l'expressió en un grup de captura. Compareu-ho amb una referència que coincideixi amb el resultat. Per exemple /(a|b)\g'1'/ pot coincidir amb ab, perquè l'expressió a|b es torna a avaluar.
Hi ha múltiples sintaxis per a aquesta funció: \g&lt;1&gt; \g'1' (?1).

També s'admeten els valors relatius precedits de + o -. Per exemple \g&lt;-1&gt; coincidiria amb el grup que precedeix la referència.</value>
  </data>
  <data name="CheatSheetOctalEscape" xml:space="preserve">
    <value>Escapada octal</value>
  </data>
  <data name="CheatSheetOctalEscapeDetails" xml:space="preserve">
    <value>Caràcter d'escapada octal en la forma \000. El valor ha de ser inferior a 255 (\377).
La sintaxi \o{FFF} també és compatible.</value>
  </data>
  <data name="CheatSheetOptional" xml:space="preserve">
    <value>Opcional</value>
  </data>
  <data name="CheatSheetOptionalDetails" xml:space="preserve">
    <value>Coincideix amb 0 o 1 de la fitxa anterior, de manera que és opcional.</value>
  </data>
  <data name="CheatSheetPlus" xml:space="preserve">
    <value>Més</value>
  </data>
  <data name="CheatSheetPlusDetails" xml:space="preserve">
    <value>Coincideix amb 1 o més del token anterior.</value>
  </data>
  <data name="CheatSheetPositiveLookahead" xml:space="preserve">
    <value>Lookahead positiva</value>
  </data>
  <data name="CheatSheetPositiveLookaheadDetails" xml:space="preserve">
    <value>Relaciona un grup després de l'expressió principal sense incloure-la al resultat.</value>
  </data>
  <data name="CheatSheetPositiveLookbehind" xml:space="preserve">
    <value>Lookbehind positiva</value>
  </data>
  <data name="CheatSheetPositiveLookbehindDetails" xml:space="preserve">
    <value>Relaciona un grup abans de l'expressió principal sense incloure-la al resultat.</value>
  </data>
  <data name="CheatSheetPossessive" xml:space="preserve">
    <value>Possessiu</value>
  </data>
  <data name="CheatSheetPossessiveDetails" xml:space="preserve">
    <value>Fa possessiu el quantificador anterior. Coincidirà amb tants caràcters com sigui possible i no els alliberarà per coincidir amb fitxes posteriors.
Per exemple /.*a/ coincidiria amb aaa, però /.*+a/ no, perquè el punt que es repeteix coincidiria i no deixaria anar l'últim caràcter per coincidir amb a.</value>
  </data>
  <data name="CheatSheetPreviousMatchEnd" xml:space="preserve">
    <value>Final de la coincidència anterior</value>
  </data>
  <data name="CheatSheetPreviousMatchEndDetails" xml:space="preserve">
    <value>Coincideix amb la posició final de la coincidència anterior. Això coincideix amb una posició, no un caràcter.</value>
  </data>
  <data name="CheatSheetQuantifier" xml:space="preserve">
    <value>Quantificador</value>
  </data>
  <data name="CheatSheetQuantifierDetails" xml:space="preserve">
    <value>Coincideix amb la quantitat especificada del token anterior. {1,3} coincidirà entre 1 i 3. {3} coincidirà exactament amb 3. {3,} coincidirà amb 3 o més.</value>
  </data>
  <data name="CheatSheetRecursion" xml:space="preserve">
    <value>Recursivitat</value>
  </data>
  <data name="CheatSheetRecursionDetails" xml:space="preserve">
    <value>S'intenta fer coincidir l'expressió completa de nou a la posició actual.
Per exemple, /a(?R)?b/ coincidirà amb qualsevol número de a seguit del mateix nombre de z: el text complet de az o aaaazzzz, però no azzz.

Hi ha diverses sintaxis per a aquesta funció:

(?R) (?0) \g&lt;0&gt; \g'0'</value>
  </data>
  <data name="CheatSheetReservedCharacters" xml:space="preserve">
    <value>Caràcters reservats</value>
  </data>
  <data name="CheatSheetReservedCharactersDetails" xml:space="preserve">
    <value>El caràcter següent té un significat especial i ha d'anar precedit d'una \ (barra invertida) per representar un caràcter literal:
+*?^$\.[]{}()|/

Dins d'un conjunt de caràcters, només cal escapar \, - i ].</value>
  </data>
  <data name="CheatSheetStar" xml:space="preserve">
    <value>Destacat</value>
  </data>
  <data name="CheatSheetStarDetails" xml:space="preserve">
    <value>Coincideix amb 0 o més del token anterior.</value>
  </data>
  <data name="CheatSheetStrictEndOfString" xml:space="preserve">
    <value>Final estricte de la cadena</value>
  </data>
  <data name="CheatSheetStrictEndOfStringDetails" xml:space="preserve">
    <value>Coincideix amb el final de la cadena. A diferència de $ o \Z, no permet una nova línia al final. Això no es veu afectat per la marca de multilínia (m). Això coincideix amb una posició, no un caràcter.</value>
  </data>
  <data name="CheatSheetSyntax" xml:space="preserve">
    <value>Sintaxi</value>
  </data>
  <data name="CheatSheetTab" xml:space="preserve">
    <value>Tabulador</value>
  </data>
  <data name="CheatSheetTabDetails" xml:space="preserve">
    <value>Coincideix amb un caràcter TAB (codi de caràcters 9).</value>
  </data>
  <data name="CheatSheetTitle" xml:space="preserve">
    <value>Full de característiques</value>
  </data>
  <data name="CheatSheetUnicodeCategory" xml:space="preserve">
    <value>Categoria Unicode</value>
  </data>
  <data name="CheatSheetUnicodeCategoryDetails" xml:space="preserve">
    <value>Coincideix amb un caràcter de la categoria Unicode especificada. Per exemple, \p{Ll} coincidirà amb qualsevol lletra minúscula.</value>
  </data>
  <data name="CheatSheetUnicodeEscape" xml:space="preserve">
    <value>Escape Unicode</value>
  </data>
  <data name="CheatSheetUnicodeEscapeDetails" xml:space="preserve">
    <value>Caràcter d'escapada Unicode en la forma \x{FF}.</value>
  </data>
  <data name="CheatSheetUnicodeGrapheme" xml:space="preserve">
    <value>Grafema Unicode</value>
  </data>
  <data name="CheatSheetUnicodeGraphemeDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol grafema unicode (és a dir, caràcter). Això inclou salts de línia (independentment del mode dotall) i grafemes codificats com a múltiples punts de codi.</value>
  </data>
  <data name="CheatSheetUnicodeScript" xml:space="preserve">
    <value>Script Unicode</value>
  </data>
  <data name="CheatSheetUnicodeScriptDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter de l'script Unicode especificat. Per exemple, \p{Arabic} coincidirà amb caràcters de l'escriptura àrab.</value>
  </data>
  <data name="CheatSheetVerticalWhitespace" xml:space="preserve">
    <value>Espai en blanc vertical</value>
  </data>
  <data name="CheatSheetVerticalWhitespaceDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter d'espai en blanc vertical (salts de línia).</value>
  </data>
  <data name="CheatSheetWhitespace" xml:space="preserve">
    <value>Espai en blanc</value>
  </data>
  <data name="CheatSheetWhitespaceDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter d'espai en blanc (espais, tabuladors, salts de línia).</value>
  </data>
  <data name="CheatSheetWord" xml:space="preserve">
    <value>Paraula</value>
  </data>
  <data name="CheatSheetWordBoundary" xml:space="preserve">
    <value>Límit de paraula</value>
  </data>
  <data name="CheatSheetWordBoundaryDetails" xml:space="preserve">
    <value>Relaciona una posició límit de paraula entre un caràcter de paraula i un caràcter o una posició que no són de paraula (inici / final de la cadena). Consulteu la classe de caràcters de paraula (w) per obtenir més informació.</value>
  </data>
  <data name="CheatSheetWordDetails" xml:space="preserve">
    <value>Coincideix amb qualsevol caràcter de paraula (alfanumèric i guió baix). Només coincideix amb caràcters de low-ASCII (sense caràcters accentuats o no romans). Equivalent a [A-Za-z0-9_]</value>
  </data>
  <data name="Configuration" xml:space="preserve">
    <value>Configuració</value>
  </data>
  <data name="CultureInvariant" xml:space="preserve">
    <value>Cultura invariant</value>
  </data>
  <data name="CultureInvariantDescription" xml:space="preserve">
    <value>Especifica que s'ignoren les diferències culturals de l'idioma.</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Valida i prova expressions regulars</value>
  </data>
  <data name="EcmaScript" xml:space="preserve">
    <value>ECMA Script</value>
  </data>
  <data name="EcmaScriptDescription" xml:space="preserve">
    <value>Habilita un comportament compatible amb ECMAScript per a l'expressió. Aquest valor només es pot utilitzar juntament amb les opcions Cultura invariant, Ignore Case i Multilínia.</value>
  </data>
  <data name="IgnoreCase" xml:space="preserve">
    <value>Ignora majúscules/minúscules</value>
  </data>
  <data name="IgnoreCaseDescription" xml:space="preserve">
    <value>Especifica que no distingeixi entre majúscules i minúscules.</value>
  </data>
  <data name="IgnoreWhitespace" xml:space="preserve">
    <value>Ignora els espais en blanc</value>
  </data>
  <data name="IgnoreWhitespaceDescription" xml:space="preserve">
    <value>Elimina l'espai en blanc sense escapar del patró i activa els comentaris marcats amb #. Tanmateix, aquest valor no afecta ni elimina els espais en blanc a les classes de caràcters, quantificadors numèrics o fitxes que marquen l'inici dels elements individuals del llenguatge d'expressió regular.</value>
  </data>
  <data name="LongDisplayTitle" xml:space="preserve">
    <value>Tester d'expressions regulars</value>
  </data>
  <data name="MatchGroupPrefix" xml:space="preserve">
    <value>Grup</value>
  </data>
  <data name="MatchInformation" xml:space="preserve">
    <value>Informació de la coincidència</value>
  </data>
  <data name="MatchLocation" xml:space="preserve">
    <value>Ubicació</value>
  </data>
  <data name="MatchName" xml:space="preserve">
    <value>Nom</value>
  </data>
  <data name="MatchNamePrefix" xml:space="preserve">
    <value>Coincidència</value>
  </data>
  <data name="MatchValue" xml:space="preserve">
    <value>Valor</value>
  </data>
  <data name="Multiline" xml:space="preserve">
    <value>Multilínia</value>
  </data>
  <data name="MultilineDescription" xml:space="preserve">
    <value>Canvia el significat de ^ i $ perquè coincideixin al principi i al final, respectivament, de qualsevol línia, i no només al començament i al final de la cadena sencera.</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>Opcions</value>
  </data>
  <data name="RegularExpression" xml:space="preserve">
    <value>Expressió regular</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>Dreta a esquerra</value>
  </data>
  <data name="RightToLeftDescription" xml:space="preserve">
    <value>Especifica que la cerca serà de dreta a esquerra en lloc d'esquerra a dreta.</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value>expressió regular</value>
  </data>
  <data name="ShortDisplayTitle" xml:space="preserve">
    <value>RegEx</value>
  </data>
  <data name="Singleline" xml:space="preserve">
    <value>Línia única</value>
  </data>
  <data name="SinglelineDescription" xml:space="preserve">
    <value>Canvia el significat del punt (.) perquè coincideixi amb tots els caràcters (en lloc de tots els caràcters excepte \n).</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>Text</value>
  </data>
</root>