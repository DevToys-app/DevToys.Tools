<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Testeur d'expression reguliere</value>
  </data>
  <data name="AllMatches" xml:space="preserve">
    <value>Tous les matchs</value>
  </data>
  <data name="AllMatchesDescription" xml:space="preserve">
    <value>Trouver toutes les correspondances dans le texte ou s'arrêter après la première correspondance.</value>
  </data>
  <data name="CheatSheetAlternation" xml:space="preserve">
    <value>Alternative</value>
  </data>
  <data name="CheatSheetAlternationDetails" xml:space="preserve">
    <value>Acts like a boolean OR. Matches the expression before or after the |.
It can operate within a group, or on a whole expression. The patterns will be tested in order.</value>
  </data>
  <data name="CheatSheetAnyCharacter" xml:space="preserve">
    <value>N'importe quel caractère, sauf le saut de ligne</value>
  </data>
  <data name="CheatSheetAnyCharacterDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère autre que le saut de ligne. Équivalent à [^\n\r].</value>
  </data>
  <data name="CheatSheetAtomicGroup" xml:space="preserve">
    <value>Groupe atomique</value>
  </data>
  <data name="CheatSheetAtomicGroupDetails" xml:space="preserve">
    <value>Groupe non capturant qui se défausse des positions de suivi une fois correspondantes.
Par exemple, /(?&gt;ab|a)b/ correspondra à l'abb mais pas à ab car une fois que l'option ab a été trouvée, le groupe atomique évite le retour en arrière pour réessayer avec une option.</value>
  </data>
  <data name="CheatSheetBeginning" xml:space="preserve">
    <value>Début</value>
  </data>
  <data name="CheatSheetBeginningDetails" xml:space="preserve">
    <value>Correspond au début de la chaîne, ou au début d'une ligne si le drapeau multiligne (m) est activé. Cela correspond à une position, pas à un caractère.</value>
  </data>
  <data name="CheatSheetBeginningOfString" xml:space="preserve">
    <value>Début de la chaîne</value>
  </data>
  <data name="CheatSheetBeginningOfStringDetails" xml:space="preserve">
    <value>Correspond au début de la chaîne. Contrairement à ^, cela n'est pas affecté par le drapeau multiligne (m).</value>
  </data>
  <data name="CheatSheetBell" xml:space="preserve">
    <value>Cloche</value>
  </data>
  <data name="CheatSheetBellDetails" xml:space="preserve">
    <value>Correspond à un caractère BELL (code de caractère 7).</value>
  </data>
  <data name="CheatSheetBranchResetGroup" xml:space="preserve">
    <value>Groupe de réinitialisation de la branche</value>
  </data>
  <data name="CheatSheetBranchResetGroupDetails" xml:space="preserve">
    <value>Définissez des groupes alternatifs qui partagent les mêmes numéros de groupe.
Par exemple, dans (?|(a)|(b)) les deux groupes (un et b) seraient comptés comme le groupe #1.</value>
  </data>
  <data name="CheatSheetCaptureGroup" xml:space="preserve">
    <value>Groupe de capture</value>
  </data>
  <data name="CheatSheetCaptureGroupDetails" xml:space="preserve">
    <value>Insère les résultats du groupe de capture spécifié. Par exemple, $3 insérera le troisième groupe de capture.
Il y a plusieurs syntaxes pour cette fonctionnalité :

$1 \1 \{1}</value>
  </data>
  <data name="CheatSheetCapturingGroup" xml:space="preserve">
    <value>Capture de groupe</value>
  </data>
  <data name="CheatSheetCapturingGroupDetails" xml:space="preserve">
    <value>Groupe plusieurs jetons ensemble et crée un groupe de capture pour extraire une sous-chaîne ou utiliser une référence arrière.</value>
  </data>
  <data name="CheatSheetCarriageReturn" xml:space="preserve">
    <value>Retour chariot</value>
  </data>
  <data name="CheatSheetCarriageReturnDetails" xml:space="preserve">
    <value>Correspond à un caractère CARRIAGE RETURN (code de caractère 13).</value>
  </data>
  <data name="CheatSheetCategoryAnchors" xml:space="preserve">
    <value>Ancres</value>
  </data>
  <data name="CheatSheetCategoryCharacterClasses" xml:space="preserve">
    <value>Classes de caractères</value>
  </data>
  <data name="CheatSheetCategoryEscapedCharacters" xml:space="preserve">
    <value>Caractère d'échappement</value>
  </data>
  <data name="CheatSheetCategoryGroupsReferences" xml:space="preserve">
    <value>Groupes et Références</value>
  </data>
  <data name="CheatSheetCategoryLookaround" xml:space="preserve">
    <value>Regarder les environs</value>
  </data>
  <data name="CheatSheetCategoryQuantifiersAlternation" xml:space="preserve">
    <value>Quantificateurs et Alternation</value>
  </data>
  <data name="CheatSheetCategorySpecial" xml:space="preserve">
    <value>Spécial</value>
  </data>
  <data name="CheatSheetCategorySubstitution" xml:space="preserve">
    <value>Substitution</value>
  </data>
  <data name="CheatSheetCharacterRange" xml:space="preserve">
    <value>Plage de caractères</value>
  </data>
  <data name="CheatSheetCharacterRangeDetails" xml:space="preserve">
    <value>Correspond à un caractère ayant un code entre les deux caractères spécifiés inclusivement.</value>
  </data>
  <data name="CheatSheetCharacterSet" xml:space="preserve">
    <value>Un seul caractère de A, b ou c</value>
  </data>
  <data name="CheatSheetCharacterSetDetails" xml:space="preserve">
    <value>Correspond soit à un caractère A, b ou c</value>
  </data>
  <data name="CheatSheetComment" xml:space="preserve">
    <value>Commenter</value>
  </data>
  <data name="CheatSheetCommentDetails" xml:space="preserve">
    <value>Vous permet d'insérer un commentaire dans votre expression qui est ignorée lors de la recherche d'une correspondance.</value>
  </data>
  <data name="CheatSheetConditional" xml:space="preserve">
    <value>Conditionnel</value>
  </data>
  <data name="CheatSheetConditionalDetails" xml:space="preserve">
    <value>Correspond conditionnellement à l'une des deux options en fonction du fait qu'un lookaround est apparié.
Par exemple, /(?(?=a)ab|.. / correspondra à ab et zx mais pas ax, parce que si le premier caractère correspond à la condition a alors il évalue le masque ab.

Tout lookaround peut être utilisé comme la condition. Une anticipation commencera le match suivant au début de la condition, un lookbehind le lancera après.</value>
  </data>
  <data name="CheatSheetControlCharacterEscape" xml:space="preserve">
    <value>Contrôler l'échappement des caractères</value>
  </data>
  <data name="CheatSheetControlCharacterEscapeDetails" xml:space="preserve">
    <value>Caractère de contrôle échappé sous la forme \cZ. Cela peut aller de \cA (SOH, code de caractère 1) à \cZ (SUB, code de caractère 26).</value>
  </data>
  <data name="CheatSheetDefine" xml:space="preserve">
    <value>Définir</value>
  </data>
  <data name="CheatSheetDefineDetails" xml:space="preserve">
    <value>Used to define named groups for use as subroutines without including them in the match.
For example, /A(?(DEFINE)(?'foo'Z))B\g'foo'/ will match ABZ, because the define group is ignored in the match except to define the foo subroutine that is referenced later with \g'foo'.</value>
  </data>
  <data name="CheatSheetDescription" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="CheatSheetDigit" xml:space="preserve">
    <value>Chiffre</value>
  </data>
  <data name="CheatSheetDigitDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère numérique (0-9). Équivalent à [0-9].</value>
  </data>
  <data name="CheatSheetEnd" xml:space="preserve">
    <value>Fin</value>
  </data>
  <data name="CheatSheetEndDetails" xml:space="preserve">
    <value>Correspond à la fin de la chaîne, ou à la fin d'une ligne si le drapeau multiligne (m) est activé. Cela correspond à une position, pas à un caractère.</value>
  </data>
  <data name="CheatSheetEndOfString" xml:space="preserve">
    <value>Fin de la chaîne</value>
  </data>
  <data name="CheatSheetEndOfStringDetails" xml:space="preserve">
    <value>Correspond à la fin de la chaîne. Contrairement à $, elle n'est pas affectée par le drapeau multiligne (m). Cela correspond à une position et non à un caractère.</value>
  </data>
  <data name="CheatSheetEsc" xml:space="preserve">
    <value>Esc</value>
  </data>
  <data name="CheatSheetEscapedCharacters" xml:space="preserve">
    <value>Caractères échappés</value>
  </data>
  <data name="CheatSheetEscapedCharactersDetails" xml:space="preserve">
    <value>Pour plus de commodité, ces caractères échappés sont pris en charge dans la chaîne de remplacement de RegExr: \n, \r, \t, \\, et unicode échappe à \uFFFF. Cela peut varier dans votre environnement de déploiement.</value>
  </data>
  <data name="CheatSheetEscapeSequence" xml:space="preserve">
    <value>Séquence de fuite</value>
  </data>
  <data name="CheatSheetEscapeSequenceDetails" xml:space="preserve">
    <value>Tous les caractères entre le \Q et le \E sont interprétés comme une chaîne littérale. Si \E est omis, il continue à la fin de l'expression. Par exemple, l'expression /\Q(?.)\E/ correspondra à la chaîne (?.).</value>
  </data>
  <data name="CheatSheetEscDetails" xml:space="preserve">
    <value>Correspond à un caractère ESC (code de caractère 27).</value>
  </data>
  <data name="CheatSheetFormFeed" xml:space="preserve">
    <value>Flux de formulaire</value>
  </data>
  <data name="CheatSheetFormFeedDetails" xml:space="preserve">
    <value>Correspond à un caractère FORM FEED (code caractère 12).</value>
  </data>
  <data name="CheatSheetGroupConditional" xml:space="preserve">
    <value>Groupe conditionnel</value>
  </data>
  <data name="CheatSheetGroupConditionalDetails" xml:space="preserve">
    <value>Conditionally matches one of two options based on whether group 'undefined' matched.
For example, /(z)?(?(1)a|b)/ will match za because the first capture group matches z successfully, which causes the conditional to match the first option a.

The same pattern will also match b on its own, because group 1 doesn't match, so it instead tries to match the second option b.

You can reference a group by name, number, or relative position (ex. -1).</value>
  </data>
  <data name="CheatSheetHexadecimalEscape" xml:space="preserve">
    <value>Échappement hexadécimal</value>
  </data>
  <data name="CheatSheetHexadecimalEscapeDetails" xml:space="preserve">
    <value>Caractère échappé hexadécimal sous la forme \xFF</value>
  </data>
  <data name="CheatSheetHorizontalWhitespace" xml:space="preserve">
    <value>Espacement horizontal</value>
  </data>
  <data name="CheatSheetHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère d'espacement horizontal (espaces, tabulations).</value>
  </data>
  <data name="CheatSheetKeepOut" xml:space="preserve">
    <value>Garder dehors</value>
  </data>
  <data name="CheatSheetKeepOutDetails" xml:space="preserve">
    <value>Garder le texte correspondant si loin de la correspondance retournée, essentiellement en rejetant la correspondance jusqu'à ce point. ou l'exemple /o\Kbar/ correspondra à la barre dans la chaîne foobar</value>
  </data>
  <data name="CheatSheetLazy" xml:space="preserve">
    <value>Lazy</value>
  </data>
  <data name="CheatSheetLazyDetails" xml:space="preserve">
    <value>Rend paresseux le quantificateur précédent, le faisant correspondre le moins de caractères possible. Par défaut, les quantificateurs sont gourmands et correspondent au plus grand nombre de caractères possible.
Ce comportement est inversé par le flag/modificateur non gourmand.</value>
  </data>
  <data name="CheatSheetLineBreak" xml:space="preserve">
    <value>Saut de ligne</value>
  </data>
  <data name="CheatSheetLineBreakDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère de saut de ligne, y compris la paire CRLF, et CR / LF individuellement.</value>
  </data>
  <data name="CheatSheetLineFeed" xml:space="preserve">
    <value>Flux de ligne</value>
  </data>
  <data name="CheatSheetLineFeedDetails" xml:space="preserve">
    <value>Correspond au caractère LIGNE FEED (code de caractère 10).</value>
  </data>
  <data name="CheatSheetMatch" xml:space="preserve">
    <value>Correspondance</value>
  </data>
  <data name="CheatSheetMatchAny" xml:space="preserve">
    <value>Correspondre à n'importe quel</value>
  </data>
  <data name="CheatSheetMatchAnyDetails" xml:space="preserve">
    <value>Un jeu de caractères qui peut être utilisé pour faire correspondre n'importe quel caractère, y compris les sauts de ligne, sans le ou les marqueurs de point.</value>
  </data>
  <data name="CheatSheetMatchDetails" xml:space="preserve">
    <value>Insère le texte correspondant.
Il y a plusieurs syntaxes pour cette fonctionnalité :

$0 \0 \{0}</value>
  </data>
  <data name="CheatSheetModeModifier" xml:space="preserve">
    <value>Mode modifier</value>
  </data>
  <data name="CheatSheetModeModifierDetails" xml:space="preserve">
    <value>Active ou désactive les modes pour le reste de l'expression. Les modes de correspondance correspondent généralement aux paramètres d'expression. Par exemple (?i) permettrait l'insensibilité du cas pour le reste de l'expression.
Les modificateurs multiples peuvent être spécifiés, et tous les modificateurs qui suivent - sont désactivés. Par exemple (?im-s) activerait l'insensibilité de la casse et les modes multilignes, et désactiverait dotall.

Les modificateurs supportés sont: i - insensible à la casse, s - point, m - multiligne, x - espacement libre, J - autoriser les noms en double, U - indigne.</value>
  </data>
  <data name="CheatSheetNamedCapturingGroup" xml:space="preserve">
    <value>Nom du groupe de capture</value>
  </data>
  <data name="CheatSheetNamedCapturingGroupDetails" xml:space="preserve">
    <value>Crée un groupe de capture qui peut être référencé via le nom spécifié.
Il y a plusieurs syntaxes pour cette fonctionnalité :

(?'name'ABC) (?P&lt;name&gt;ABC) (?&lt;name&gt;ABC)</value>
  </data>
  <data name="CheatSheetNamedReference" xml:space="preserve">
    <value>Référence nommée</value>
  </data>
  <data name="CheatSheetNamedReferenceDetails" xml:space="preserve">
    <value>Correspond aux résultats d'un groupe de capture nommé.
Il y a plusieurs syntaxes pour cette fonctionnalité :

\k'name' \k&lt;name&gt; \k{name} \g{name} (?P=nom)</value>
  </data>
  <data name="CheatSheetNamedSubroutine" xml:space="preserve">
    <value>Sous-routine nommée</value>
  </data>
  <data name="CheatSheetNamedSubroutineDetails" xml:space="preserve">
    <value>Correspond à l'expression dans un groupe de capture. Comparer ceci à une référence, qui correspond au résultat.
Il y a plusieurs syntaxes pour cette fonctionnalité : \g&lt;name&gt; \g'name' (?&amp;name) (?P&gt;name).</value>
  </data>
  <data name="CheatSheetNegatedCharacterSet" xml:space="preserve">
    <value>Un caractère sauf A, b ou c</value>
  </data>
  <data name="CheatSheetNegatedCharacterSetDetails" xml:space="preserve">
    <value>Faire correspondre tout caractère qui n'est pas A, b ou c.</value>
  </data>
  <data name="CheatSheetNegativeLookahead" xml:space="preserve">
    <value>Anticipation négative</value>
  </data>
  <data name="CheatSheetNegativeLookaheadDetails" xml:space="preserve">
    <value>Spécifie un groupe qui ne peut pas correspondre après l'expression principale (si elle correspond, le résultat est rejeté).</value>
  </data>
  <data name="CheatSheetNegativeLookbehind" xml:space="preserve">
    <value>Derrière le regard négatif</value>
  </data>
  <data name="CheatSheetNegativeLookbehindDetails" xml:space="preserve">
    <value>Spécifie un groupe qui ne peut pas correspondre avant l'expression principale (si elle correspond, le résultat est rejeté).</value>
  </data>
  <data name="CheatSheetNonCapturingGroup" xml:space="preserve">
    <value>Groupe non capturant</value>
  </data>
  <data name="CheatSheetNonCapturingGroupDetails" xml:space="preserve">
    <value>Groupes plusieurs jetons ensemble sans créer de groupe de capture.</value>
  </data>
  <data name="CheatSheetNotDigit" xml:space="preserve">
    <value>Pas de chiffre</value>
  </data>
  <data name="CheatSheetNotDigitDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère qui n'est pas un chiffre (0-9). Équivalent à [^0-9].</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespace" xml:space="preserve">
    <value>Espacement non horizontal</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère qui n'est pas un caractère d'espacement horizontal (espaces, tabulations).</value>
  </data>
  <data name="CheatSheetNotLineBreak" xml:space="preserve">
    <value>Pas de saut de ligne</value>
  </data>
  <data name="CheatSheetNotLineBreakDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère qui n'est pas un saut de ligne. Similaire au point (.) mais qui n'est pas affecté par le(s) drapeau(s).</value>
  </data>
  <data name="CheatSheetNotUnicodeCategory" xml:space="preserve">
    <value>Catégorie non unicode</value>
  </data>
  <data name="CheatSheetNotUnicodeCategoryDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère qui n'est pas dans la catégorie unicode spécifiée.</value>
  </data>
  <data name="CheatSheetNotUnicodeScript" xml:space="preserve">
    <value>Script non unicode</value>
  </data>
  <data name="CheatSheetNotUnicodeScriptDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère qui n'est pas dans le script unicode spécifié.</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespace" xml:space="preserve">
    <value>Espacement non vertical</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespaceDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère qui n'est pas un caractère d'espacement vertical (saut de ligne).</value>
  </data>
  <data name="CheatSheetNotWhitespace" xml:space="preserve">
    <value>Pas d'espace</value>
  </data>
  <data name="CheatSheetNotWhitespaceDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère qui n'est pas un caractère d'espacement (espaces, tabulations, sauts de ligne).</value>
  </data>
  <data name="CheatSheetNotWord" xml:space="preserve">
    <value>Pas de mot</value>
  </data>
  <data name="CheatSheetNotWordBoundary" xml:space="preserve">
    <value>Pas de limite de mot</value>
  </data>
  <data name="CheatSheetNotWordBoundaryDetails" xml:space="preserve">
    <value>Correspond à n'importe quelle position qui n'est pas une limite de mot. Cela correspond à une position, et non à un caractère.</value>
  </data>
  <data name="CheatSheetNotWordDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère qui n'est pas un mot (alphanumérique et underscore). Équivalent à [^A-Za-z0-9_]</value>
  </data>
  <data name="CheatSheetNull" xml:space="preserve">
    <value>Null</value>
  </data>
  <data name="CheatSheetNullDetails" xml:space="preserve">
    <value>Correspond à un caractère NULL (code de caractère 0).</value>
  </data>
  <data name="CheatSheetNumericReference" xml:space="preserve">
    <value>Numeric reference</value>
  </data>
  <data name="CheatSheetNumericReferenceDetails" xml:space="preserve">
    <value>Matches the results of a capture group. For example \1 matches the results of the first capture group &amp; \3 matches the third.
There are multiple syntaxes for this feature: \1 \g1 \g{1}.

The latter syntaxes support relative values preceded by + or -. For example \g-1 would match the group preceding the reference.</value>
  </data>
  <data name="CheatSheetNumericSubroutine" xml:space="preserve">
    <value>Numeric subroutine</value>
  </data>
  <data name="CheatSheetNumericSubroutineDetails" xml:space="preserve">
    <value>Matches the expression in a capture group. Compare this to a reference, that matches the result. For example /(a|b)\g'1'/ can match ab, because the expression a|b is evaluated again.
There are multiple syntaxes for this feature: \g&lt;1&gt; \g'1' (?1).

Relative values preceded by + or - are also supported. For example \g&lt;-1&gt; would match the group preceding the reference.</value>
  </data>
  <data name="CheatSheetOctalEscape" xml:space="preserve">
    <value>Echappement Octal</value>
  </data>
  <data name="CheatSheetOctalEscapeDetails" xml:space="preserve">
    <value>Caractère échappé Octal sous la forme \000. La valeur doit être inférieure à 255 (\377).
La syntaxe \o{FFF} est également prise en charge.</value>
  </data>
  <data name="CheatSheetOptional" xml:space="preserve">
    <value>Optionnel</value>
  </data>
  <data name="CheatSheetOptionalDetails" xml:space="preserve">
    <value>Correspond à 0 ou 1 du jeton précédent, le rendant en fait facultatif.</value>
  </data>
  <data name="CheatSheetPlus" xml:space="preserve">
    <value>Plus</value>
  </data>
  <data name="CheatSheetPlusDetails" xml:space="preserve">
    <value>Correspond à 1 ou plus du jeton précédent.</value>
  </data>
  <data name="CheatSheetPositiveLookahead" xml:space="preserve">
    <value>Anticipation positive</value>
  </data>
  <data name="CheatSheetPositiveLookaheadDetails" xml:space="preserve">
    <value>Correspond à un groupe après l'expression principale sans l'inclure dans le résultat.</value>
  </data>
  <data name="CheatSheetPositiveLookbehind" xml:space="preserve">
    <value>Vue positive derrière</value>
  </data>
  <data name="CheatSheetPositiveLookbehindDetails" xml:space="preserve">
    <value>Correspond à un groupe avant l'expression principale sans l'inclure dans le résultat.</value>
  </data>
  <data name="CheatSheetPossessive" xml:space="preserve">
    <value>Possessif</value>
  </data>
  <data name="CheatSheetPossessiveDetails" xml:space="preserve">
    <value>Makes the preceding quantifier possessive. It will match as many characters as possible, and will not release them to match subsequent tokens.
For example /.*a/ would match aaa, but /.*+a/ would not, because the repeating dot would match and not release the last character to match a.</value>
  </data>
  <data name="CheatSheetPreviousMatchEnd" xml:space="preserve">
    <value>Fin de la partie précédente</value>
  </data>
  <data name="CheatSheetPreviousMatchEndDetails" xml:space="preserve">
    <value>Correspond à la position de fin de la partie précédente. Cela correspond à une position et non à un caractère.</value>
  </data>
  <data name="CheatSheetQuantifier" xml:space="preserve">
    <value>Quantifier</value>
  </data>
  <data name="CheatSheetQuantifierDetails" xml:space="preserve">
    <value>Correspond à la quantité spécifiée du jeton précédent. {1,3} correspondra de 1 à 3. {3} correspondra exactement 3. {3,} correspondra 3 ou plus.</value>
  </data>
  <data name="CheatSheetRecursion" xml:space="preserve">
    <value>Récursion</value>
  </data>
  <data name="CheatSheetRecursionDetails" xml:space="preserve">
    <value>Tente de faire correspondre l'expression complète à la position courante.
Par exemple, /a(?R)? / fera correspondre n'importe quel nombre d'un suivi par le même nombre de z: le texte complet de az ou aaaazzzz, mais pas azzz.

Il y a plusieurs syntaxes pour cette fonctionnalité :

(?R) (?0) \g&lt;0&gt; \g'0'</value>
  </data>
  <data name="CheatSheetReservedCharacters" xml:space="preserve">
    <value>Caractères réservés</value>
  </data>
  <data name="CheatSheetReservedCharactersDetails" xml:space="preserve">
    <value>Le caractère suivant a une signification spéciale et doit être précédé d'un \ (antislash) pour représenter un caractère littéral :
+*?^$\. ]{}()|/

Dans un jeu de caractères, seuls \, -, et ] doivent être échappés.</value>
  </data>
  <data name="CheatSheetStar" xml:space="preserve">
    <value>Étoiles</value>
  </data>
  <data name="CheatSheetStarDetails" xml:space="preserve">
    <value>Correspond à 0 ou plus du jeton précédent.</value>
  </data>
  <data name="CheatSheetStrictEndOfString" xml:space="preserve">
    <value>Fin stricte de la chaîne</value>
  </data>
  <data name="CheatSheetStrictEndOfStringDetails" xml:space="preserve">
    <value>Correspond à la fin de la chaîne. Contrairement à $ ou \Z, il ne permet pas une nouvelle ligne. Ceci n'est pas affecté par le drapeau multiligne (m). Cela correspond à une position et non à un caractère.</value>
  </data>
  <data name="CheatSheetSyntax" xml:space="preserve">
    <value>Syntaxe</value>
  </data>
  <data name="CheatSheetTab" xml:space="preserve">
    <value>Tab</value>
  </data>
  <data name="CheatSheetTabDetails" xml:space="preserve">
    <value>Correspond à un caractère TAB (code de caractère 9).</value>
  </data>
  <data name="CheatSheetTitle" xml:space="preserve">
    <value>Feuille de triche</value>
  </data>
  <data name="CheatSheetUnicodeCategory" xml:space="preserve">
    <value>Catégorie Unicode</value>
  </data>
  <data name="CheatSheetUnicodeCategoryDetails" xml:space="preserve">
    <value>Correspond à un caractère dans la catégorie unicode spécifiée. Par exemple, \p{Ll} correspondra à n'importe quelle lettre minuscule.</value>
  </data>
  <data name="CheatSheetUnicodeEscape" xml:space="preserve">
    <value>Échappement Unicode</value>
  </data>
  <data name="CheatSheetUnicodeEscapeDetails" xml:space="preserve">
    <value>Caractère échappé Unicode sous la forme \x{FF}.</value>
  </data>
  <data name="CheatSheetUnicodeGrapheme" xml:space="preserve">
    <value>Graphème Unicode</value>
  </data>
  <data name="CheatSheetUnicodeGraphemeDetails" xml:space="preserve">
    <value>Correspond à n'importe quel grapheme unicode (par ex. caractère). Cela inclut les sauts de ligne (quel que soit le mode dotall) et les graphèmes codés en plusieurs points de code.</value>
  </data>
  <data name="CheatSheetUnicodeScript" xml:space="preserve">
    <value>Script Unicode</value>
  </data>
  <data name="CheatSheetUnicodeScriptDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère dans le script unicode spécifié. Par exemple, \p{Arabic} fera correspondre les caractères dans le script arabe.</value>
  </data>
  <data name="CheatSheetVerticalWhitespace" xml:space="preserve">
    <value>Espacement vertical</value>
  </data>
  <data name="CheatSheetVerticalWhitespaceDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère d'espacement vertical (saut de ligne).</value>
  </data>
  <data name="CheatSheetWhitespace" xml:space="preserve">
    <value>Whitespace</value>
  </data>
  <data name="CheatSheetWhitespaceDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère d'espacement (espaces, tabulations, sauts de ligne).</value>
  </data>
  <data name="CheatSheetWord" xml:space="preserve">
    <value>Mot</value>
  </data>
  <data name="CheatSheetWordBoundary" xml:space="preserve">
    <value>Limite de mot</value>
  </data>
  <data name="CheatSheetWordBoundaryDetails" xml:space="preserve">
    <value>Correspond à la position de limite entre un caractère de mot et un caractère ou une position de non-mot (début / fin de chaîne). Voir la classe de caractère de mot (w) pour plus d'informations.</value>
  </data>
  <data name="CheatSheetWordDetails" xml:space="preserve">
    <value>Correspond à n'importe quel caractère de mot (alphanumérique &amp; underscore). Correspond uniquement aux caractères basse ascii (sans caractères accentués ou non romans). Équivalent à [A-Za-z0-9_]</value>
  </data>
  <data name="Configuration" xml:space="preserve">
    <value>Configuration</value>
  </data>
  <data name="CultureInvariant" xml:space="preserve">
    <value>Invariante culturelle</value>
  </data>
  <data name="CultureInvariantDescription" xml:space="preserve">
    <value>Spécifie que les différences culturelles dans la langue sont ignorées.</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Valider et tester les expressions régulières</value>
  </data>
  <data name="EcmaScript" xml:space="preserve">
    <value>Script ECMA</value>
  </data>
  <data name="EcmaScriptDescription" xml:space="preserve">
    <value>Active le comportement conforme à ECMAScript pour l'expression. Cette valeur ne peut être utilisée qu'en conjonction avec les options Culture Invariant, Ignore Case et Multiline.</value>
  </data>
  <data name="IgnoreCase" xml:space="preserve">
    <value>Ignorer la casse</value>
  </data>
  <data name="IgnoreCaseDescription" xml:space="preserve">
    <value>Spécifie la correspondance insensible à la casse.</value>
  </data>
  <data name="IgnoreWhitespace" xml:space="preserve">
    <value>Ignorer les espaces</value>
  </data>
  <data name="IgnoreWhitespaceDescription" xml:space="preserve">
    <value>Élimine l'espace blanc non échappé du motif et active les commentaires marqués par #. Cependant, cette valeur n'affecte pas ou n'élimine pas l'espace blanc dans les classes de caractères, les quantificateurs numériques, ou jetons qui marquent le début des éléments de langage d'expression rationnelle individuelle.</value>
  </data>
  <data name="LongDisplayTitle" xml:space="preserve">
    <value>Testeur d'expressions régulières</value>
  </data>
  <data name="MatchGroupPrefix" xml:space="preserve">
    <value>Groupes</value>
  </data>
  <data name="MatchInformation" xml:space="preserve">
    <value>Informations sur le match</value>
  </data>
  <data name="MatchLocation" xml:space="preserve">
    <value>Localisation</value>
  </data>
  <data name="MatchName" xml:space="preserve">
    <value>Nom</value>
  </data>
  <data name="MatchNamePrefix" xml:space="preserve">
    <value>Correspondance</value>
  </data>
  <data name="MatchValue" xml:space="preserve">
    <value>Valeur</value>
  </data>
  <data name="Multiline" xml:space="preserve">
    <value>Multiligne</value>
  </data>
  <data name="MultilineDescription" xml:space="preserve">
    <value>Modifie la signification de ^ et $ afin qu'ils correspondent respectivement au début et à la fin, de n'importe quelle ligne, et pas seulement le début et la fin de la chaîne entière.</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>Options</value>
  </data>
  <data name="RegularExpression" xml:space="preserve">
    <value>Expression régulière</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>Droite à Gauche</value>
  </data>
  <data name="RightToLeftDescription" xml:space="preserve">
    <value>Spécifie que la recherche sera de droite à gauche au lieu de gauche à droite.</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value>expression régulière</value>
  </data>
  <data name="ShortDisplayTitle" xml:space="preserve">
    <value>RegEx</value>
  </data>
  <data name="Singleline" xml:space="preserve">
    <value>Singleline</value>
  </data>
  <data name="SinglelineDescription" xml:space="preserve">
    <value>Modifie la signification du point (.) afin qu'il corresponde à chaque caractère (au lieu de chaque caractère sauf \n).</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>Texte du texte</value>
  </data>
</root>