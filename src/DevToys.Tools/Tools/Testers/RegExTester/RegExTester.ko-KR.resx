<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>정규식 테스터 도구</value>
  </data>
  <data name="AllMatches" xml:space="preserve">
    <value>모든 일치</value>
  </data>
  <data name="AllMatchesDescription" xml:space="preserve">
    <value>텍스트에서 모든 일치 항목을 찾거나 첫 번째 일치 항목에서 중지합니다.</value>
  </data>
  <data name="CheatSheetAlternation" xml:space="preserve">
    <value>교대</value>
  </data>
  <data name="CheatSheetAlternationDetails" xml:space="preserve">
    <value>부울 OR처럼 작동합니다. 앞뒤의 표현식을 일치시킵니다. 그룹 내에서 또는 전체 표현식에 대해 작동할 수 있습니다. 패턴은 순서대로 테스트됩니다.</value>
  </data>
  <data name="CheatSheetAnyCharacter" xml:space="preserve">
    <value>줄 바꿈을 제외한 모든 문자</value>
  </data>
  <data name="CheatSheetAnyCharacterDetails" xml:space="preserve">
    <value>줄바꿈 이외의 모든 문자와 일치합니다. [^\n\r] 과 동일합니다.</value>
  </data>
  <data name="CheatSheetAtomicGroup" xml:space="preserve">
    <value>원자 그룹</value>
  </data>
  <data name="CheatSheetAtomicGroupDetails" xml:space="preserve">
    <value>일단 일치하면 역추적 위치를 폐기하는 비캡처 그룹입니다.
예를 들어, /(?&gt;ab|a)b/는 abb와 일치하지만 ab와는 일치하지 않습니다. 왜냐하면 ab 옵션이 일치하면 원자 그룹이 a 옵션을 사용하여 재시도하는 역추적을 방지하기 때문입니다.</value>
  </data>
  <data name="CheatSheetBeginning" xml:space="preserve">
    <value>시작</value>
  </data>
  <data name="CheatSheetBeginningDetails" xml:space="preserve">
    <value>문자열의 시작 부분과 일치하거나 여러 줄 플래그(m) 가 활성화된 경우 줄의 시작 부분과 일치합니다. 이는 문자가 아닌 위치와 일치합니다.</value>
  </data>
  <data name="CheatSheetBeginningOfString" xml:space="preserve">
    <value>문자열의 시작</value>
  </data>
  <data name="CheatSheetBeginningOfStringDetails" xml:space="preserve">
    <value>문자열의 시작 부분과 일치합니다. ^와 달리 여러 줄 플래그(m) 의 영향을 받지 않습니다. 이는 문자가 아닌 위치와 일치합니다.</value>
  </data>
  <data name="CheatSheetBell" xml:space="preserve">
    <value>벨</value>
  </data>
  <data name="CheatSheetBellDetails" xml:space="preserve">
    <value>BELL 문자 (문자 코드 7)와 일치합니다.</value>
  </data>
  <data name="CheatSheetBranchResetGroup" xml:space="preserve">
    <value>브랜치 재설정 그룹</value>
  </data>
  <data name="CheatSheetBranchResetGroupDetails" xml:space="preserve">
    <value>동일한 그룹 번호를 공유하는 대체 그룹을 정의합니다.
예를 들어, (?|(a)|(b)) 에서 두 그룹(a 및 b) 은 그룹 #1로 계산됩니다.</value>
  </data>
  <data name="CheatSheetCaptureGroup" xml:space="preserve">
    <value>캡처 그룹</value>
  </data>
  <data name="CheatSheetCaptureGroupDetails" xml:space="preserve">
    <value>지정된 캡처 그룹의 결과를 삽입합니다. 예를 들어 $3은 세 번째 캡처 그룹을 삽입합니다.
이 기능에는 여러 가지 구문이 있습니다.

$1 \1 \{1}</value>
  </data>
  <data name="CheatSheetCapturingGroup" xml:space="preserve">
    <value>그룹 캡처</value>
  </data>
  <data name="CheatSheetCapturingGroupDetails" xml:space="preserve">
    <value>여러 토큰을 함께 그룹화하고 하위 문자열을 추출하거나 역참조를 사용하기 위한 캡처 그룹을 생성합니다.</value>
  </data>
  <data name="CheatSheetCarriageReturn" xml:space="preserve">
    <value>캐리지 반환</value>
  </data>
  <data name="CheatSheetCarriageReturnDetails" xml:space="preserve">
    <value>캐리지 반환 문자(문자 코드 13) 와 일치합니다.</value>
  </data>
  <data name="CheatSheetCategoryAnchors" xml:space="preserve">
    <value>앵커</value>
  </data>
  <data name="CheatSheetCategoryCharacterClasses" xml:space="preserve">
    <value>캐릭터 클래스</value>
  </data>
  <data name="CheatSheetCategoryEscapedCharacters" xml:space="preserve">
    <value>이스케이프 문자</value>
  </data>
  <data name="CheatSheetCategoryGroupsReferences" xml:space="preserve">
    <value>그룹 및 참조</value>
  </data>
  <data name="CheatSheetCategoryLookaround" xml:space="preserve">
    <value>둘러보기</value>
  </data>
  <data name="CheatSheetCategoryQuantifiersAlternation" xml:space="preserve">
    <value>수량화 및 대체</value>
  </data>
  <data name="CheatSheetCategorySpecial" xml:space="preserve">
    <value>특수</value>
  </data>
  <data name="CheatSheetCategorySubstitution" xml:space="preserve">
    <value>대체</value>
  </data>
  <data name="CheatSheetCharacterRange" xml:space="preserve">
    <value>문자 범위</value>
  </data>
  <data name="CheatSheetCharacterRangeDetails" xml:space="preserve">
    <value>지정된 두 문자 사이에 문자 코드가 있는 문자를 찾습니다.</value>
  </data>
  <data name="CheatSheetCharacterSet" xml:space="preserve">
    <value>A, b 또는 c의 단일 문자</value>
  </data>
  <data name="CheatSheetCharacterSetDetails" xml:space="preserve">
    <value>A, b 또는 c 문자와 일치합니다.</value>
  </data>
  <data name="CheatSheetComment" xml:space="preserve">
    <value>코멘트</value>
  </data>
  <data name="CheatSheetCommentDetails" xml:space="preserve">
    <value>일치 항목을 찾을 때 무시되는 주석을 표현식에 삽입할 수 있습니다.</value>
  </data>
  <data name="CheatSheetConditional" xml:space="preserve">
    <value>조건부</value>
  </data>
  <data name="CheatSheetConditionalDetails" xml:space="preserve">
    <value>둘러보기가 일치하는지 여부에 따라 두 옵션 중 하나를 조건부로 일치시킵니다.
예를 들어, /(?(?=a)ab|..)/는 ab 및 zx와 일치하지만 ax는 일치하지 않습니다. 왜냐하면 첫 번째 문자가 조건 a와 일치하면 패턴 ab를 평가하기 때문입니다.

모든 둘러보기를 조건으로 사용할 수 있습니다. 미리보기는 조건이 시작될 때 후속 매치를 시작하고, 미리보기는 조건이 시작된 후에 시작됩니다.</value>
  </data>
  <data name="CheatSheetControlCharacterEscape" xml:space="preserve">
    <value>제어 문자 이스케이프</value>
  </data>
  <data name="CheatSheetControlCharacterEscapeDetails" xml:space="preserve">
    <value>\cZ 형식의 이스케이프 제어 문자입니다. 범위는 \cA(SOH, 문자 코드 1) 부터 \cZ(SUB, 문자 코드 26) 까지입니다.</value>
  </data>
  <data name="CheatSheetDefine" xml:space="preserve">
    <value>정의</value>
  </data>
  <data name="CheatSheetDefineDetails" xml:space="preserve">
    <value>이름이 지정된 그룹을 일치 항목에 포함하지 않고 하위 루틴으로 사용하도록 정의하는 데 사용됩니다.
예를 들어, /A(?(DEFINE)('foo'Z))B\g'foo'/는 ABZ와 일치합니다. 나중에 \g'foo와 함께 참조되는 foo 서브루틴을 정의하는 것을 제외하고는 일치에서 정의 그룹이 무시되기 때문입니다.</value>
  </data>
  <data name="CheatSheetDescription" xml:space="preserve">
    <value>설명</value>
  </data>
  <data name="CheatSheetDigit" xml:space="preserve">
    <value>자릿수</value>
  </data>
  <data name="CheatSheetDigitDetails" xml:space="preserve">
    <value>모든 숫자 문자(0-9) 와 일치합니다. [0-9] 와 동일합니다.</value>
  </data>
  <data name="CheatSheetEnd" xml:space="preserve">
    <value>끝</value>
  </data>
  <data name="CheatSheetEndDetails" xml:space="preserve">
    <value>문자열의 끝과 일치하거나 여러 줄 플래그(m) 가 활성화된 경우 줄의 끝과 일치합니다. 이는 문자가 아닌 위치와 일치합니다.</value>
  </data>
  <data name="CheatSheetEndOfString" xml:space="preserve">
    <value>문자열 끝</value>
  </data>
  <data name="CheatSheetEndOfStringDetails" xml:space="preserve">
    <value>문자열의 끝과 일치합니다. $와 달리 이는 여러 줄 플래그(m) 의 영향을 받지 않습니다. 이는 문자가 아닌 위치와 일치합니다.</value>
  </data>
  <data name="CheatSheetEsc" xml:space="preserve">
    <value>Esc</value>
  </data>
  <data name="CheatSheetEscapedCharacters" xml:space="preserve">
    <value>이스케이프 문자</value>
  </data>
  <data name="CheatSheetEscapedCharactersDetails" xml:space="preserve">
    <value>편의를 위해 이러한 이스케이프 문자는 RegExr의 바꾸기 문자열에서 지원됩니다: \n, \r, \t, \\ 및 유니코드 이스케이프 \uFFFF. 이는 배포 환경에 따라 다를 수 있습니다.</value>
  </data>
  <data name="CheatSheetEscapeSequence" xml:space="preserve">
    <value>이스케이프 시퀀스</value>
  </data>
  <data name="CheatSheetEscapeSequenceDetails" xml:space="preserve">
    <value>\Q와 \E 사이의 모든 문자는 리터럴 문자열로 해석됩니다. \E를 생략하면 표현식 끝까지 계속됩니다. 예를 들어, /\Q(?.)\E/ 표현식은 문자열(?.) 과 일치합니다.</value>
  </data>
  <data name="CheatSheetEscDetails" xml:space="preserve">
    <value>ESC 문자(문자 코드 27) 와 일치합니다.</value>
  </data>
  <data name="CheatSheetFormFeed" xml:space="preserve">
    <value>양식 피드</value>
  </data>
  <data name="CheatSheetFormFeedDetails" xml:space="preserve">
    <value>FORM FEED 문자(문자 코드 12) 와 일치합니다.</value>
  </data>
  <data name="CheatSheetGroupConditional" xml:space="preserve">
    <value>그룹 조건부</value>
  </data>
  <data name="CheatSheetGroupConditionalDetails" xml:space="preserve">
    <value>그룹 '정의되지 않음'이 일치하는지 여부에 따라 두 옵션 중 하나를 조건부로 일치시킵니다.
예를 들어 /(z)?(?(1)a|b)/는 첫 번째 캡처 그룹이 z와 성공적으로 일치하므로 조건이 첫 번째 옵션 a와 일치하므로 za와 일치합니다.

동일한 패턴은 그룹 1이 일치하지 않기 때문에 b 자체와 일치하므로 대신 두 번째 옵션 b와 일치하려고 시도합니다.

이름, 번호 또는 상대 위치(예: -1)로 그룹을 참조할 수 있습니다.</value>
  </data>
  <data name="CheatSheetHexadecimalEscape" xml:space="preserve">
    <value>16진수 이스케이프</value>
  </data>
  <data name="CheatSheetHexadecimalEscapeDetails" xml:space="preserve">
    <value>\xFF 형식의 16진수 이스케이프 문자입니다.</value>
  </data>
  <data name="CheatSheetHorizontalWhitespace" xml:space="preserve">
    <value>가로 공백</value>
  </data>
  <data name="CheatSheetHorizontalWhitespaceDetails" xml:space="preserve">
    <value>가로 공백 문자(공백, 탭) 와 일치합니다.</value>
  </data>
  <data name="CheatSheetKeepOut" xml:space="preserve">
    <value>유지 금지</value>
  </data>
  <data name="CheatSheetKeepOutDetails" xml:space="preserve">
    <value>반환된 일치 항목 중 지금까지 일치된 텍스트를 유지하고 본질적으로 이 지점까지 일치 항목을 삭제합니다. 예를 들어 /o\Kbar/는 foobar 문자열 내의 bar와 일치합니다.</value>
  </data>
  <data name="CheatSheetLazy" xml:space="preserve">
    <value>게으른</value>
  </data>
  <data name="CheatSheetLazyDetails" xml:space="preserve">
    <value>선행 수량자를 지연시켜 가능한 적은 수의 문자와 일치하도록 만듭니다. 기본적으로 수량자는 탐욕적이며 가능한 한 많은 문자와 일치합니다.
이 동작은 ungreedy(U) 플래그/수정자에 의해 반전됩니다.</value>
  </data>
  <data name="CheatSheetLineBreak" xml:space="preserve">
    <value>줄 바꿈</value>
  </data>
  <data name="CheatSheetLineBreakDetails" xml:space="preserve">
    <value>CRLF 쌍 및 CR / LF를 포함하여 모든 줄 바꿈 문자와 개별적으로 일치합니다.</value>
  </data>
  <data name="CheatSheetLineFeed" xml:space="preserve">
    <value>줄 바꿈</value>
  </data>
  <data name="CheatSheetLineFeedDetails" xml:space="preserve">
    <value>Matches a LINE FEED character (char code 10).</value>
  </data>
  <data name="CheatSheetMatch" xml:space="preserve">
    <value>Match</value>
  </data>
  <data name="CheatSheetMatchAny" xml:space="preserve">
    <value>Match any</value>
  </data>
  <data name="CheatSheetMatchAnyDetails" xml:space="preserve">
    <value>A character set that can be used to match any character, including line breaks, without the dotall flag (s).</value>
  </data>
  <data name="CheatSheetMatchDetails" xml:space="preserve">
    <value>Inserts the matched text.
There are multiple syntaxes for this feature:

$0 \0 \{0}</value>
  </data>
  <data name="CheatSheetModeModifier" xml:space="preserve">
    <value>Mode modifier</value>
  </data>
  <data name="CheatSheetModeModifierDetails" xml:space="preserve">
    <value>Enables or disables modes for the remainder of the expression.Matching modes generally map to expression flags. For example (?i) would enable case insensitivity for the remainder of the expression.
Multiple modifiers can be specified, and any modifiers that follow - are disabled. For example (?im-s) would enable case insensitivity &amp; multiline modes, and disable dotall.

Supported modifiers are: i - case insensitive, s - dotall, m - multiline, x - free spacing, J - allow duplicate names, U - ungreedy.</value>
  </data>
  <data name="CheatSheetNamedCapturingGroup" xml:space="preserve">
    <value>Named capturing group</value>
  </data>
  <data name="CheatSheetNamedCapturingGroupDetails" xml:space="preserve">
    <value>Creates a capturing group that can be referenced via the specified name.
There are multiple syntaxes for this feature:

(?'name'ABC) (?P&lt;name&gt;ABC) (?&lt;name&gt;ABC)</value>
  </data>
  <data name="CheatSheetNamedReference" xml:space="preserve">
    <value>Named reference</value>
  </data>
  <data name="CheatSheetNamedReferenceDetails" xml:space="preserve">
    <value>Matches the results of a named capture group.
There are multiple syntaxes for this feature:

\k'name' \k&lt;name&gt; \k{name} \g{name} (?P=name)</value>
  </data>
  <data name="CheatSheetNamedSubroutine" xml:space="preserve">
    <value>Named subroutine</value>
  </data>
  <data name="CheatSheetNamedSubroutineDetails" xml:space="preserve">
    <value>Matches the expression in a capture group. Compare this to a reference, that matches the result.
There are multiple syntaxes for this feature: \g&lt;name&gt; \g'name' (?&amp;name) (?P&gt;name).</value>
  </data>
  <data name="CheatSheetNegatedCharacterSet" xml:space="preserve">
    <value>A character except A, b or c</value>
  </data>
  <data name="CheatSheetNegatedCharacterSetDetails" xml:space="preserve">
    <value>Match any character that is not A, b or c.</value>
  </data>
  <data name="CheatSheetNegativeLookahead" xml:space="preserve">
    <value>Negative lookahead</value>
  </data>
  <data name="CheatSheetNegativeLookaheadDetails" xml:space="preserve">
    <value>Specifies a group that can not match after the main expression (if it matches, the result is discarded).</value>
  </data>
  <data name="CheatSheetNegativeLookbehind" xml:space="preserve">
    <value>Negative lookbehind</value>
  </data>
  <data name="CheatSheetNegativeLookbehindDetails" xml:space="preserve">
    <value>Specifies a group that can not match before the main expression (if it matches, the result is discarded).</value>
  </data>
  <data name="CheatSheetNonCapturingGroup" xml:space="preserve">
    <value>Non-capturing group</value>
  </data>
  <data name="CheatSheetNonCapturingGroupDetails" xml:space="preserve">
    <value>Groups multiple tokens together without creating a capture group.</value>
  </data>
  <data name="CheatSheetNotDigit" xml:space="preserve">
    <value>Not digit</value>
  </data>
  <data name="CheatSheetNotDigitDetails" xml:space="preserve">
    <value>Matches any character that is not a digit character (0-9). Equivalent to [^0-9].</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespace" xml:space="preserve">
    <value>Not horizontal whitespace</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Matches any character that is not a horizontal whitespace character (spaces, tabs).</value>
  </data>
  <data name="CheatSheetNotLineBreak" xml:space="preserve">
    <value>Not line break</value>
  </data>
  <data name="CheatSheetNotLineBreakDetails" xml:space="preserve">
    <value>Matches any character that is not a line break. Similar to dot (.) but is unaffected by the dotall flag (s).</value>
  </data>
  <data name="CheatSheetNotUnicodeCategory" xml:space="preserve">
    <value>Not unicode category</value>
  </data>
  <data name="CheatSheetNotUnicodeCategoryDetails" xml:space="preserve">
    <value>Matches any character that is not in the specified unicode category.</value>
  </data>
  <data name="CheatSheetNotUnicodeScript" xml:space="preserve">
    <value>Not unicode script</value>
  </data>
  <data name="CheatSheetNotUnicodeScriptDetails" xml:space="preserve">
    <value>Matches any character that is not in the specified unicode script.</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespace" xml:space="preserve">
    <value>Not vertical whitespace</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespaceDetails" xml:space="preserve">
    <value>Matches any character that is not a vertical whitespace character (line breaks).</value>
  </data>
  <data name="CheatSheetNotWhitespace" xml:space="preserve">
    <value>Not whitespace</value>
  </data>
  <data name="CheatSheetNotWhitespaceDetails" xml:space="preserve">
    <value>Matches any character that is not a whitespace character (spaces, tabs, line breaks).</value>
  </data>
  <data name="CheatSheetNotWord" xml:space="preserve">
    <value>Not word</value>
  </data>
  <data name="CheatSheetNotWordBoundary" xml:space="preserve">
    <value>Not word boundary</value>
  </data>
  <data name="CheatSheetNotWordBoundaryDetails" xml:space="preserve">
    <value>Matches any position that is not a word boundary. This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetNotWordDetails" xml:space="preserve">
    <value>단어 문자(영숫자 및 밑줄) 가 아닌 모든 문자와 일치합니다. [^A-Za-z0-9_] 와 동일</value>
  </data>
  <data name="CheatSheetNull" xml:space="preserve">
    <value>Null</value>
  </data>
  <data name="CheatSheetNullDetails" xml:space="preserve">
    <value>NULL 문자(문자 코드 0) 와 일치합니다.</value>
  </data>
  <data name="CheatSheetNumericReference" xml:space="preserve">
    <value>숫자 참조</value>
  </data>
  <data name="CheatSheetNumericReferenceDetails" xml:space="preserve">
    <value>캡처 그룹의 결과와 일치합니다. 예를 들어 \1은 첫 번째 캡처 그룹의 결과와 일치하고 \3은 세 번째 캡처 그룹의 결과와 일치합니다.
이 기능에는 \1 \g1 \g{1} 등 여러 가지 구문이 있습니다.

후자 구문은 + 또는 - 앞에 상대 값을 지원합니다. 예를 들어 \g-1은 참조 앞에 있는 그룹과 일치합니다.</value>
  </data>
  <data name="CheatSheetNumericSubroutine" xml:space="preserve">
    <value>숫자 서브루틴</value>
  </data>
  <data name="CheatSheetNumericSubroutineDetails" xml:space="preserve">
    <value>캡처 그룹의 표현식과 일치합니다. 이를 결과와 일치하는 참조와 비교하십시오. 예를 들어 /(a|b)\g'1'/은 a|b 표현식이 다시 평가되므로 ab와 일치할 수 있습니다.
이 기능에는 여러 가지 구문이 있습니다: \g&lt;1&gt; \g'1' (?1).

+ 또는 - 앞에 오는 상대 값도 지원됩니다. 예를 들어 \g&lt;-1&gt; 참조 앞의 그룹과 일치합니다.</value>
  </data>
  <data name="CheatSheetOctalEscape" xml:space="preserve">
    <value>8진수 이스케이프</value>
  </data>
  <data name="CheatSheetOctalEscapeDetails" xml:space="preserve">
    <value>\000 형식의 8진수 이스케이프 문자입니다. 값은 255(\377) 보다 작아야 합니다.
\o{FFF} 구문도 지원됩니다.</value>
  </data>
  <data name="CheatSheetOptional" xml:space="preserve">
    <value>선택사항</value>
  </data>
  <data name="CheatSheetOptionalDetails" xml:space="preserve">
    <value>앞의 토큰 중 0 또는 1과 일치하여 사실상 선택 사항이 됩니다.</value>
  </data>
  <data name="CheatSheetPlus" xml:space="preserve">
    <value>더하기</value>
  </data>
  <data name="CheatSheetPlusDetails" xml:space="preserve">
    <value>앞의 토큰 중 1개 이상과 일치합니다.</value>
  </data>
  <data name="CheatSheetPositiveLookahead" xml:space="preserve">
    <value>긍정적인 예측</value>
  </data>
  <data name="CheatSheetPositiveLookaheadDetails" xml:space="preserve">
    <value>주 표현식 뒤에 있는 그룹을 결과에 포함하지 않고 일치시킵니다.</value>
  </data>
  <data name="CheatSheetPositiveLookbehind" xml:space="preserve">
    <value>긍정적인 예측</value>
  </data>
  <data name="CheatSheetPositiveLookbehindDetails" xml:space="preserve">
    <value>결과에 포함하지 않고 주 표현식 앞에 있는 그룹을 일치시킵니다.</value>
  </data>
  <data name="CheatSheetPossessive" xml:space="preserve">
    <value>소유격</value>
  </data>
  <data name="CheatSheetPossessiveDetails" xml:space="preserve">
    <value>앞의 수량자를 소유격으로 만듭니다. 가능한 한 많은 문자와 일치하며 후속 토큰과 일치하도록 해당 문자를 해제하지 않습니다.
예를 들어 /.*a/는 aaa와 일치하지만 /.*+a/는 그렇지 않습니다. 왜냐하면 반복되는 점이 일치하고 a와 일치하는 마지막 문자를 해제하지 않기 때문입니다.</value>
  </data>
  <data name="CheatSheetPreviousMatchEnd" xml:space="preserve">
    <value>이전 경기 종료</value>
  </data>
  <data name="CheatSheetPreviousMatchEndDetails" xml:space="preserve">
    <value>이전 일치의 끝 위치와 일치합니다. 이는 문자가 아닌 위치와 일치합니다.</value>
  </data>
  <data name="CheatSheetQuantifier" xml:space="preserve">
    <value>수량자</value>
  </data>
  <data name="CheatSheetQuantifierDetails" xml:space="preserve">
    <value>이전 토큰의 지정된 수량과 일치합니다. {1,3} 은 1 대 3과 일치합니다. {3} 은 정확히 3과 일치합니다. {3,} 는 3 이상과 일치합니다.</value>
  </data>
  <data name="CheatSheetRecursion" xml:space="preserve">
    <value>재귀</value>
  </data>
  <data name="CheatSheetRecursionDetails" xml:space="preserve">
    <value>현재 위치에서 전체 표현식을 다시 일치시키려고 시도합니다.
예를 들어, /a(?R)?b/는 임의의 수의 a 다음에 동일한 수의 z가 오는 것과 일치합니다. 즉, az 또는 aaaazzzz의 전체 텍스트와 일치하지만 azzz는 일치하지 않습니다.

이 기능에는 여러 가지 구문이 있습니다.

(?R) (?0) \g&lt;0&gt; \g'0'</value>
  </data>
  <data name="CheatSheetReservedCharacters" xml:space="preserve">
    <value>예약 문자</value>
  </data>
  <data name="CheatSheetReservedCharactersDetails" xml:space="preserve">
    <value>다음 문자는 특별한 의미를 가지며 리터럴 문자를 나타내려면 \(백슬래시) 가 앞에 와야 합니다.
+*?^$\.[]{}()|/

문자 집합 내에서는 \, - 및 ] 만 이스케이프해야 합니다.</value>
  </data>
  <data name="CheatSheetStar" xml:space="preserve">
    <value>별표</value>
  </data>
  <data name="CheatSheetStarDetails" xml:space="preserve">
    <value>이전 토큰 중 0개 이상과 일치합니다.</value>
  </data>
  <data name="CheatSheetStrictEndOfString" xml:space="preserve">
    <value>문자열의 엄격한 끝</value>
  </data>
  <data name="CheatSheetStrictEndOfStringDetails" xml:space="preserve">
    <value>문자열의 끝과 일치합니다. $ 또는 \Z와 달리 후행 개행을 허용하지 않습니다. 이는 여러 줄 플래그(m) 의 영향을 받지 않습니다. 이는 문자가 아닌 위치와 일치합니다.</value>
  </data>
  <data name="CheatSheetSyntax" xml:space="preserve">
    <value>구문</value>
  </data>
  <data name="CheatSheetTab" xml:space="preserve">
    <value>탭</value>
  </data>
  <data name="CheatSheetTabDetails" xml:space="preserve">
    <value>TAB 문자(문자 코드 9) 와 일치합니다.</value>
  </data>
  <data name="CheatSheetTitle" xml:space="preserve">
    <value>치트 시트</value>
  </data>
  <data name="CheatSheetUnicodeCategory" xml:space="preserve">
    <value>유니코드 카테고리</value>
  </data>
  <data name="CheatSheetUnicodeCategoryDetails" xml:space="preserve">
    <value>지정된 유니코드 범주의 문자와 일치합니다. 예를 들어, \p{Ll} 은 모든 소문자와 일치합니다.</value>
  </data>
  <data name="CheatSheetUnicodeEscape" xml:space="preserve">
    <value>유니코드 이스케이프</value>
  </data>
  <data name="CheatSheetUnicodeEscapeDetails" xml:space="preserve">
    <value>\x{FF} 형식의 유니코드 이스케이프 문자입니다.</value>
  </data>
  <data name="CheatSheetUnicodeGrapheme" xml:space="preserve">
    <value>유니코드 문자소</value>
  </data>
  <data name="CheatSheetUnicodeGraphemeDetails" xml:space="preserve">
    <value>단일 유니코드 문자소(예: 문자) 와 일치합니다. 여기에는 줄바꿈(dotall 모드와 관계없이) 과 여러 코드 포인트로 인코딩된 문자소가 포함됩니다.</value>
  </data>
  <data name="CheatSheetUnicodeScript" xml:space="preserve">
    <value>유니코드 스크립트</value>
  </data>
  <data name="CheatSheetUnicodeScriptDetails" xml:space="preserve">
    <value>지정된 유니코드 스크립트의 모든 문자와 일치합니다. 예를 들어, \p{Arabic} 은 아랍어 스크립트의 문자와 일치합니다.</value>
  </data>
  <data name="CheatSheetVerticalWhitespace" xml:space="preserve">
    <value>세로 공백</value>
  </data>
  <data name="CheatSheetVerticalWhitespaceDetails" xml:space="preserve">
    <value>세로 공백 문자(줄 바꿈) 와 일치합니다.</value>
  </data>
  <data name="CheatSheetWhitespace" xml:space="preserve">
    <value>공백</value>
  </data>
  <data name="CheatSheetWhitespaceDetails" xml:space="preserve">
    <value>모든 공백 문자(공백, 탭, 줄 바꿈) 와 일치합니다.</value>
  </data>
  <data name="CheatSheetWord" xml:space="preserve">
    <value>단어</value>
  </data>
  <data name="CheatSheetWordBoundary" xml:space="preserve">
    <value>단어 경계</value>
  </data>
  <data name="CheatSheetWordBoundaryDetails" xml:space="preserve">
    <value>단어 문자와 단어가 아닌 문자 또는 위치(문자열의 시작/끝) 사이의 단어 경계 위치를 일치시킵니다. 자세한 내용은 단어 문자 클래스(w) 를 참조하세요.</value>
  </data>
  <data name="CheatSheetWordDetails" xml:space="preserve">
    <value>모든 단어 문자(영숫자 및 밑줄) 와 일치합니다. 낮은 Ascii 문자만 일치합니다(악센트 부호 또는 비로마자 문자 없음). [A-Za-z0-9_] 와 동일</value>
  </data>
  <data name="Configuration" xml:space="preserve">
    <value>설정</value>
  </data>
  <data name="CultureInvariant" xml:space="preserve">
    <value>문화 불변</value>
  </data>
  <data name="CultureInvariantDescription" xml:space="preserve">
    <value>언어의 문화적 차이를 무시하도록 지정합니다.</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>정규식 검증 및 테스트</value>
  </data>
  <data name="EcmaScript" xml:space="preserve">
    <value>ECMA 스크립트</value>
  </data>
  <data name="EcmaScriptDescription" xml:space="preserve">
    <value>식에 대해 ECMA스크립트 호환 동작을 사용합니다. 이 값은 문화 불변, 대소문자 무시및 여러줄 옵션과 함께만 사용할 수 있습니다.</value>
  </data>
  <data name="IgnoreCase" xml:space="preserve">
    <value>대소문자 무시</value>
  </data>
  <data name="IgnoreCaseDescription" xml:space="preserve">
    <value>대소문자를 구분하지 않는 일치를 지정합니다.</value>
  </data>
  <data name="IgnoreWhitespace" xml:space="preserve">
    <value>공백 무시</value>
  </data>
  <data name="IgnoreWhitespaceDescription" xml:space="preserve">
    <value># 문자로 시작하는 주석 같은 경우, 이후 별도로 인코딩하지 않은 공백 사용 시 해당 줄을 제거합니다. 그러나 언어에 명시된 문자로 이루어진 클래스, 수치 식별자, 토큰 등에 포함된 공백은 영향을 미치지 않습니다.</value>
  </data>
  <data name="LongDisplayTitle" xml:space="preserve">
    <value>정규식 테스터</value>
  </data>
  <data name="MatchGroupPrefix" xml:space="preserve">
    <value>그룹</value>
  </data>
  <data name="MatchInformation" xml:space="preserve">
    <value>일치 정보</value>
  </data>
  <data name="MatchLocation" xml:space="preserve">
    <value>위치</value>
  </data>
  <data name="MatchName" xml:space="preserve">
    <value>이름</value>
  </data>
  <data name="MatchNamePrefix" xml:space="preserve">
    <value>일치</value>
  </data>
  <data name="MatchValue" xml:space="preserve">
    <value>값</value>
  </data>
  <data name="Multiline" xml:space="preserve">
    <value>여러줄</value>
  </data>
  <data name="MultilineDescription" xml:space="preserve">
    <value>^ 및 $ 문자를 사용하여 처음 및 끝을 맺는 정규식 사용 시 하나의 문단이 아닌 전체 텍스트를 의미하도록 부여합니다.</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>옵션</value>
  </data>
  <data name="RegularExpression" xml:space="preserve">
    <value>정규식</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>역순으로</value>
  </data>
  <data name="RightToLeftDescription" xml:space="preserve">
    <value>문자열 검색 시 왼쪽에서 오른쪽이 기본이지만, 오른쪽에서 왼쪽으로 검색 시 선택하세요.</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value>정규식</value>
  </data>
  <data name="ShortDisplayTitle" xml:space="preserve">
    <value>정규 표현식</value>
  </data>
  <data name="Singleline" xml:space="preserve">
    <value>단일 행</value>
  </data>
  <data name="SinglelineDescription" xml:space="preserve">
    <value>온점(.) 발견 시 모든 문자를 검색합니다. (기본적으로 \n 문자를 제외한 모든 문자를 검색합니다).</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>텍스트</value>
  </data>
</root>