<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Nástroj pro testování regulárních výrazů</value>
  </data>
  <data name="AllMatches" xml:space="preserve">
    <value>Všechny shody</value>
  </data>
  <data name="AllMatchesDescription" xml:space="preserve">
    <value>Najít všechny shody v textu nebo se po první shodě zastavit.</value>
  </data>
  <data name="CheatSheetAlternation" xml:space="preserve">
    <value>Střídání</value>
  </data>
  <data name="CheatSheetAlternationDetails" xml:space="preserve">
    <value>Chová se jako booleanský OR. Dává do shody výraz před nebo za znakem |.
Může fungovat v rámci skupiny nebo na celém výrazu. Vzory budou otestovány v pořadí.</value>
  </data>
  <data name="CheatSheetAnyCharacter" xml:space="preserve">
    <value>Jakýkoliv znak kromě nového řádku</value>
  </data>
  <data name="CheatSheetAnyCharacterDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak kromě nového řádku. Ekvivalentní k [^\n\r].</value>
  </data>
  <data name="CheatSheetAtomicGroup" xml:space="preserve">
    <value>Atomická skupina</value>
  </data>
  <data name="CheatSheetAtomicGroupDetails" xml:space="preserve">
    <value>Nezachycující skupina, která se zbavuje pozic zpětného zachycení po shodě. Například, /(?&gt;ab|a)b/ dá do shody abb, ale ne ab, protože jakmile se možnost ab dá do shody, atomická skupina zabrání zpětnému zachycení k opakovanému pokusu s možností a.</value>
  </data>
  <data name="CheatSheetBeginning" xml:space="preserve">
    <value>Začátek</value>
  </data>
  <data name="CheatSheetBeginningDetails" xml:space="preserve">
    <value>Dává do shody začátek řetězce nebo začátek řádku pokud je víceřádková vlajka (m) aktivována. Dává do shody pozici, ne znak.</value>
  </data>
  <data name="CheatSheetBeginningOfString" xml:space="preserve">
    <value>Začátek řetězce</value>
  </data>
  <data name="CheatSheetBeginningOfStringDetails" xml:space="preserve">
    <value>Dává do shody začátek řetězce. Na rozdíl od ^ není ovlivněno víceřádkovou vlajkou (m). Dává do shody pozici, ne znak.</value>
  </data>
  <data name="CheatSheetBell" xml:space="preserve">
    <value>Zvonek</value>
  </data>
  <data name="CheatSheetBellDetails" xml:space="preserve">
    <value>Dává do shody znak ZVONEK (char kód 7).</value>
  </data>
  <data name="CheatSheetBranchResetGroup" xml:space="preserve">
    <value>Skupina resetování větve</value>
  </data>
  <data name="CheatSheetBranchResetGroupDetails" xml:space="preserve">
    <value>Definujte alternativní skupiny, které sdílejí stejná čísla skupin.
Například, v (?|(a)|(b)) obě skupiny (a a b) by byly počítány jako skupina #1.</value>
  </data>
  <data name="CheatSheetCaptureGroup" xml:space="preserve">
    <value>Skupina zachytávaných</value>
  </data>
  <data name="CheatSheetCaptureGroupDetails" xml:space="preserve">
    <value>Vloží výsledky dané skupiny zachytávaných. Například $3 by vložilo třetí skupinu zachytávaných.
Pro tuto funkci existuje více syntaxí:

$1 \1 \{1}</value>
  </data>
  <data name="CheatSheetCapturingGroup" xml:space="preserve">
    <value>Zachytávací skupina</value>
  </data>
  <data name="CheatSheetCapturingGroupDetails" xml:space="preserve">
    <value>Seskupí více tokenů a vytvoří skupinu zachytávaných pro vyjmutí podřetězce nebo používání zpětné reference.</value>
  </data>
  <data name="CheatSheetCarriageReturn" xml:space="preserve">
    <value>Carriage return</value>
  </data>
  <data name="CheatSheetCarriageReturnDetails" xml:space="preserve">
    <value>Dává do shody znak CARRIAGE RETURN (char kód 13).</value>
  </data>
  <data name="CheatSheetCategoryAnchors" xml:space="preserve">
    <value>Ukotvení</value>
  </data>
  <data name="CheatSheetCategoryCharacterClasses" xml:space="preserve">
    <value>Znakové třídy</value>
  </data>
  <data name="CheatSheetCategoryEscapedCharacters" xml:space="preserve">
    <value>Escapované znaky</value>
  </data>
  <data name="CheatSheetCategoryGroupsReferences" xml:space="preserve">
    <value>Skupiny a odkazy</value>
  </data>
  <data name="CheatSheetCategoryLookaround" xml:space="preserve">
    <value>Rozhlédnutí</value>
  </data>
  <data name="CheatSheetCategoryQuantifiersAlternation" xml:space="preserve">
    <value>Kvantifikátory a střídání</value>
  </data>
  <data name="CheatSheetCategorySpecial" xml:space="preserve">
    <value>Speciální</value>
  </data>
  <data name="CheatSheetCategorySubstitution" xml:space="preserve">
    <value>Substituce</value>
  </data>
  <data name="CheatSheetCharacterRange" xml:space="preserve">
    <value>Rozsah znaků</value>
  </data>
  <data name="CheatSheetCharacterRangeDetails" xml:space="preserve">
    <value>Dává do shody znak, jehož char kód je mezi dvěma zadanými znaky včetně.</value>
  </data>
  <data name="CheatSheetCharacterSet" xml:space="preserve">
    <value>Jediný znak A, b nebo c</value>
  </data>
  <data name="CheatSheetCharacterSetDetails" xml:space="preserve">
    <value>Dává do shody buď znak A, b nebo c</value>
  </data>
  <data name="CheatSheetComment" xml:space="preserve">
    <value>Komentář</value>
  </data>
  <data name="CheatSheetCommentDetails" xml:space="preserve">
    <value>Umožňuje vložit komentář do vašeho výrazu, který je při hledání shody ignorován.</value>
  </data>
  <data name="CheatSheetConditional" xml:space="preserve">
    <value>Podmíněné</value>
  </data>
  <data name="CheatSheetConditionalDetails" xml:space="preserve">
    <value>Podmíněně přiřazuje jednu ze dvou možností na základě toho, zda je přiřazena možnost rozhlédnutí. Například /(?(?=a)ab|..)/ dá do shody ab a zx, ale ne ax, protože pokud první znak odpovídá podmínce a, pak vyhodnotí vzor ab. Jako podmínku lze použít libovolné rozhlédnutí. Rozhlédnutí dopředu spustí následnou shodu na začátku podmínky, rozhlédnutí dozadu ji spustí až po ní.</value>
  </data>
  <data name="CheatSheetControlCharacterEscape" xml:space="preserve">
    <value>Řídící znakový escape</value>
  </data>
  <data name="CheatSheetControlCharacterEscapeDetails" xml:space="preserve">
    <value>Escapovaný řídící znak ve tvaru \cZ. Může se pohybovat od \cA (SOH, char kód 1) do \cZ (SUB, char kód 26).</value>
  </data>
  <data name="CheatSheetDefine" xml:space="preserve">
    <value>Definování</value>
  </data>
  <data name="CheatSheetDefineDetails" xml:space="preserve">
    <value>Slouží k definování pojmenovaných skupin pro použití jako podprogramů, aniž by byly zahrnuty do shody. Například /A(?(DEFINE)(?'foo'Z))B\g'foo'/ dá do shody ABZ, protože skupina define je ve shodě ignorována s výjimkou definice podprogramu foo, na který je později odkazováno pomocí \g'foo'.</value>
  </data>
  <data name="CheatSheetDescription" xml:space="preserve">
    <value>Popis</value>
  </data>
  <data name="CheatSheetDigit" xml:space="preserve">
    <value>Číslice</value>
  </data>
  <data name="CheatSheetDigitDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv číslicový znak (0-9). Ekvivalentní k [0-9].</value>
  </data>
  <data name="CheatSheetEnd" xml:space="preserve">
    <value>Konec</value>
  </data>
  <data name="CheatSheetEndDetails" xml:space="preserve">
    <value>Dává do shody konec řetězce nebo konec řádku pokud je víceřádková vlajka (m) aktivována. Dává do shody pozici, ne znak.</value>
  </data>
  <data name="CheatSheetEndOfString" xml:space="preserve">
    <value>Konec řetězce</value>
  </data>
  <data name="CheatSheetEndOfStringDetails" xml:space="preserve">
    <value>Dává do shody konec řetězce. Na rozdíl od $ není ovlivněno víceřádkovou vlajkou (m). Dává do shody pozici, ne znak.</value>
  </data>
  <data name="CheatSheetEsc" xml:space="preserve">
    <value>Esc</value>
  </data>
  <data name="CheatSheetEscapedCharacters" xml:space="preserve">
    <value>Escapované znaky</value>
  </data>
  <data name="CheatSheetEscapedCharactersDetails" xml:space="preserve">
    <value>Pro usnadnění jsou tyto escapované znaky podporovány v řetězci Replace v RegExr: \n, \r, \t, \\ a unicode escapy \uFFFF. Může se v prostředí nasazení lišit.</value>
  </data>
  <data name="CheatSheetEscapeSequence" xml:space="preserve">
    <value>Escape sekvence</value>
  </data>
  <data name="CheatSheetEscapeSequenceDetails" xml:space="preserve">
    <value>Všechny znaky mezi \Q a \E jsou interpretovány jako doslovný řetězec. Pokud je \E vynechán, pokračuje až do konce výrazu. Například výraz /\Q(?.)\E/ dá do shody řetězec (?.).</value>
  </data>
  <data name="CheatSheetEscDetails" xml:space="preserve">
    <value>Dává do shody znak ESC (char kód 27).</value>
  </data>
  <data name="CheatSheetFormFeed" xml:space="preserve">
    <value>Form feed</value>
  </data>
  <data name="CheatSheetFormFeedDetails" xml:space="preserve">
    <value>Dává do shody znak FORM FEED (char kód 12).</value>
  </data>
  <data name="CheatSheetGroupConditional" xml:space="preserve">
    <value>Skupinové podmíněné</value>
  </data>
  <data name="CheatSheetGroupConditionalDetails" xml:space="preserve">
    <value>Podmíněně přiřazuje jednu ze dvou možností na základě toho, zda je shoda se skupinou "neuvedeno". Například /(z)?(?(1)a|b)/ dá do shody za, protože první skupina zachytávaných úspěšně dá do shody z, což způsobí, že podmínka dá shody také první možnost a.

Stejný vzor dá do shody i b samo o sobě, protože skupina 1 se neshoduje, takže se místo toho pokusí o shodu s druhou možností b. 

Na skupinu se můžete odkazovat pomocí názvu, čísla nebo relativní pozice (např. -1).</value>
  </data>
  <data name="CheatSheetHexadecimalEscape" xml:space="preserve">
    <value>Šestnáctkový escape</value>
  </data>
  <data name="CheatSheetHexadecimalEscapeDetails" xml:space="preserve">
    <value>Šestnáctkový escapovaný znak ve tvaru \xFF.</value>
  </data>
  <data name="CheatSheetHorizontalWhitespace" xml:space="preserve">
    <value>Vodorovný bílý znak</value>
  </data>
  <data name="CheatSheetHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Dává do shody jakékoliv vodorovné bílé znaky (mezery, tabulátory).</value>
  </data>
  <data name="CheatSheetKeepOut" xml:space="preserve">
    <value>Nevpouštět</value>
  </data>
  <data name="CheatSheetKeepOutDetails" xml:space="preserve">
    <value>Nevpustit doposud odpovídající text do skupiny výstupových shod, v podstatě shodu do tohoto bodu zahodit. Například /o\Kbar/ dá do shody bar uvnitř řetězce foobar</value>
  </data>
  <data name="CheatSheetLazy" xml:space="preserve">
    <value>Líný</value>
  </data>
  <data name="CheatSheetLazyDetails" xml:space="preserve">
    <value>Udělá předcházející kvantifikátor líným, což způsobí, že dá do shody co nejméně znaků. Ve výchozím nastavení jsou kvantifikátory chamtivé a budou dávat do shody znaků co nejvíce.
Toto chování je obráceno nechamtivou vlajkou/modifikátorem (U).</value>
  </data>
  <data name="CheatSheetLineBreak" xml:space="preserve">
    <value>Konec řádku</value>
  </data>
  <data name="CheatSheetLineBreakDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak konce řádku, včetně dvojice CRLF a CR / LF jednotlivě.</value>
  </data>
  <data name="CheatSheetLineFeed" xml:space="preserve">
    <value>Line feed</value>
  </data>
  <data name="CheatSheetLineFeedDetails" xml:space="preserve">
    <value>Dává do shody znak LINE FEED (char kód 10).</value>
  </data>
  <data name="CheatSheetMatch" xml:space="preserve">
    <value>Dát do shody</value>
  </data>
  <data name="CheatSheetMatchAny" xml:space="preserve">
    <value>Dát do shody jakýkoliv</value>
  </data>
  <data name="CheatSheetMatchAnyDetails" xml:space="preserve">
    <value>Sada znaků, která může dát do shody jakýkoliv znak, včetně konců řádků, kromě vlajky dotall (s).</value>
  </data>
  <data name="CheatSheetMatchDetails" xml:space="preserve">
    <value>Vloží odpovídající text.
Pro tuto funkci je více syntaxí:

$0 \0 \{0}</value>
  </data>
  <data name="CheatSheetModeModifier" xml:space="preserve">
    <value>Modifikátor režimů</value>
  </data>
  <data name="CheatSheetModeModifierDetails" xml:space="preserve">
    <value>Povoluje nebo zakazuje režimy pro zbytek výrazu. Režimy shody se obecně mapují na vlajky výrazu. Například (?i) by pro zbytek výrazu zapnul nerozlišování malých a velkých písmen.
Lze zadat více modifikátorů a všechny modifikátory, které následují za -, jsou zakázány. Například (?im-s) by zapnulo režim necitlivosti velkých a malých písmen a víceřádkové režimy a zakázalo dotall. 

Podporované modifikátory jsou: i - nerozlišování malých a velkých písmen, s - dotall, m - víceřádkový, x - volné řádkování, J - povolit duplicitní jména, U - nechamtivý.</value>
  </data>
  <data name="CheatSheetNamedCapturingGroup" xml:space="preserve">
    <value>Pojmenovaná zachytávací skupina</value>
  </data>
  <data name="CheatSheetNamedCapturingGroupDetails" xml:space="preserve">
    <value>Vytvoří zachytávací skupina, na kterou lze odkazovat pomocí zadaného názvu.
Pro tuto funkci existuje více sytnaxí:

(?'name'ABC) (?P&lt;name&gt;ABC) (?&lt;name&gt;ABC)</value>
  </data>
  <data name="CheatSheetNamedReference" xml:space="preserve">
    <value>Pojmenovaný odkaz</value>
  </data>
  <data name="CheatSheetNamedReferenceDetails" xml:space="preserve">
    <value>Dává do shody výsledky pojmenované skupiny zachytávaných.
Pro tuto funkci existuje více syntaxí:

\k'name' \k&lt;name&gt; \k{name} \g{name} (?P=name)</value>
  </data>
  <data name="CheatSheetNamedSubroutine" xml:space="preserve">
    <value>Pojmenovaná podfunkce</value>
  </data>
  <data name="CheatSheetNamedSubroutineDetails" xml:space="preserve">
    <value>Dává do shody výraz ve skupině zachytávaných. To porovná s odkazem, který odpovídá výsledku.
Pro tuto funkci existuje více syntaxí: \g&lt;name&gt; \g'name' (?&amp;name) (?P&gt;name).</value>
  </data>
  <data name="CheatSheetNegatedCharacterSet" xml:space="preserve">
    <value>Znak kromě A, b nebo c</value>
  </data>
  <data name="CheatSheetNegatedCharacterSetDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak, který není A, b nebo c.</value>
  </data>
  <data name="CheatSheetNegativeLookahead" xml:space="preserve">
    <value>Záporné rozhlédnutí dopředu</value>
  </data>
  <data name="CheatSheetNegativeLookaheadDetails" xml:space="preserve">
    <value>Určuje skupinu, která se nemůže dát do shody po hlavním výrazu (pokud se shoduje, výsledek je zahozen).</value>
  </data>
  <data name="CheatSheetNegativeLookbehind" xml:space="preserve">
    <value>Záporné rozhlédnutí dozadu</value>
  </data>
  <data name="CheatSheetNegativeLookbehindDetails" xml:space="preserve">
    <value>Určuje skupinu, která se nemůže dát do shody před hlavním výrazem (pokud se shoduje, výsledek je zahozen).</value>
  </data>
  <data name="CheatSheetNonCapturingGroup" xml:space="preserve">
    <value>Nezachytávací skupina</value>
  </data>
  <data name="CheatSheetNonCapturingGroupDetails" xml:space="preserve">
    <value>Seskupí více tokenů bez vytvoření skupiny zachytávaných.</value>
  </data>
  <data name="CheatSheetNotDigit" xml:space="preserve">
    <value>Není číslice</value>
  </data>
  <data name="CheatSheetNotDigitDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak, který není číslicový znak (0-9). Ekvivalentní k [^0-9].</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespace" xml:space="preserve">
    <value>Není vodorovný bílý znak</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak, který není vodorovný bílý znak (mezera, tabulátor).</value>
  </data>
  <data name="CheatSheetNotLineBreak" xml:space="preserve">
    <value>Není konec řádku</value>
  </data>
  <data name="CheatSheetNotLineBreakDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak, který není konec řádku. Podobné tečce (.), ale není ovlivněno vlajkou dotall (s).</value>
  </data>
  <data name="CheatSheetNotUnicodeCategory" xml:space="preserve">
    <value>Není v unicode kategorii</value>
  </data>
  <data name="CheatSheetNotUnicodeCategoryDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak, který není v zadané unicode kategorii.</value>
  </data>
  <data name="CheatSheetNotUnicodeScript" xml:space="preserve">
    <value>Není unicode skript</value>
  </data>
  <data name="CheatSheetNotUnicodeScriptDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak, který není v zadaném unicode skriptu.</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespace" xml:space="preserve">
    <value>Není svislý bílý znak</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespaceDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak, který není svislý bílý znak (konec řádky).</value>
  </data>
  <data name="CheatSheetNotWhitespace" xml:space="preserve">
    <value>Není bílý znak</value>
  </data>
  <data name="CheatSheetNotWhitespaceDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak, který není bílý znak (mezera, tabulátor, konec řádku).</value>
  </data>
  <data name="CheatSheetNotWord" xml:space="preserve">
    <value>Není slovo</value>
  </data>
  <data name="CheatSheetNotWordBoundary" xml:space="preserve">
    <value>Není slovní hranice</value>
  </data>
  <data name="CheatSheetNotWordBoundaryDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak, který není slovní hranice. Dává do shody pozici, ne znak.</value>
  </data>
  <data name="CheatSheetNotWordDetails" xml:space="preserve">
    <value>Dává do shody jakýkoliv znak, který není slovní znak (alfanumerické &amp; podtržítko). Ekvivalentní k [^A-Za-z0-9_]</value>
  </data>
  <data name="CheatSheetNull" xml:space="preserve">
    <value>Null</value>
  </data>
  <data name="CheatSheetNullDetails" xml:space="preserve">
    <value>Dává do shody znak NULL (char kód 0).</value>
  </data>
  <data name="CheatSheetNumericReference" xml:space="preserve">
    <value>Číselný odkaz</value>
  </data>
  <data name="CheatSheetNumericReferenceDetails" xml:space="preserve">
    <value>Dává do shody výsledky skupiny zachytávaných. Například \1 dává do shody výsledky první skupiny zachytávaných a \3 dává do shody tu třetí.
Pro tuto funkci existuje více syntaxí: \1 \g1 \g{1}.

Posledně zmíněné syntaxe podporují relativní hodnoty, před kterými je znak + nebo -. Například \g-1 by dalo do shody skupinu předcházející odkazu.</value>
  </data>
  <data name="CheatSheetNumericSubroutine" xml:space="preserve">
    <value>Číselná podfunkce</value>
  </data>
  <data name="CheatSheetNumericSubroutineDetails" xml:space="preserve">
    <value>Matches the expression in a capture group. Compare this to a reference, that matches the result. For example /(a|b)\g'1'/ can match ab, because the expression a|b is evaluated again.
There are multiple syntaxes for this feature: \g&lt;1&gt; \g'1' (?1).

Relative values preceded by + or - are also supported. For example \g&lt;-1&gt; would match the group preceding the reference.</value>
  </data>
  <data name="CheatSheetOctalEscape" xml:space="preserve">
    <value>Octal escape</value>
  </data>
  <data name="CheatSheetOctalEscapeDetails" xml:space="preserve">
    <value>Octal escaped character in the form \000. Value must be less than 255 (\377).
The syntax \o{FFF} is also supported.</value>
  </data>
  <data name="CheatSheetOptional" xml:space="preserve">
    <value>Optional</value>
  </data>
  <data name="CheatSheetOptionalDetails" xml:space="preserve">
    <value>Matches 0 or 1 of the preceding token, effectively making it optional.</value>
  </data>
  <data name="CheatSheetPlus" xml:space="preserve">
    <value>Plus</value>
  </data>
  <data name="CheatSheetPlusDetails" xml:space="preserve">
    <value>Matches 1 or more of the preceding token.</value>
  </data>
  <data name="CheatSheetPositiveLookahead" xml:space="preserve">
    <value>Positive lookahead</value>
  </data>
  <data name="CheatSheetPositiveLookaheadDetails" xml:space="preserve">
    <value>Matches a group after the main expression without including it in the result.</value>
  </data>
  <data name="CheatSheetPositiveLookbehind" xml:space="preserve">
    <value>Positive lookbehind</value>
  </data>
  <data name="CheatSheetPositiveLookbehindDetails" xml:space="preserve">
    <value>Matches a group before the main expression without including it in the result.</value>
  </data>
  <data name="CheatSheetPossessive" xml:space="preserve">
    <value>Possessive</value>
  </data>
  <data name="CheatSheetPossessiveDetails" xml:space="preserve">
    <value>Makes the preceding quantifier possessive. It will match as many characters as possible, and will not release them to match subsequent tokens.
For example /.*a/ would match aaa, but /.*+a/ would not, because the repeating dot would match and not release the last character to match a.</value>
  </data>
  <data name="CheatSheetPreviousMatchEnd" xml:space="preserve">
    <value>Previous match end</value>
  </data>
  <data name="CheatSheetPreviousMatchEndDetails" xml:space="preserve">
    <value>Matches the end position of the previous match. This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetQuantifier" xml:space="preserve">
    <value>Quantifier</value>
  </data>
  <data name="CheatSheetQuantifierDetails" xml:space="preserve">
    <value>Matches the specified quantity of the previous token. {1,3} will match 1 to 3. {3} will match exactly 3. {3,} will match 3 or more.</value>
  </data>
  <data name="CheatSheetRecursion" xml:space="preserve">
    <value>Recursion</value>
  </data>
  <data name="CheatSheetRecursionDetails" xml:space="preserve">
    <value>Attempts to match the full expression again at the current position.
For example, /a(?R)?b/ will match any number of a followed by the same number of z: the full text of az or aaaazzzz, but not azzz.

There are multiple syntaxes for this feature:

(?R) (?0) \g&lt;0&gt; \g'0'</value>
  </data>
  <data name="CheatSheetReservedCharacters" xml:space="preserve">
    <value>Reserved characters</value>
  </data>
  <data name="CheatSheetReservedCharactersDetails" xml:space="preserve">
    <value>The following character have special meaning, and should be preceded by a \ (backslash) to represent a literal character:
+*?^$\.[]{}()|/

Within a character set, only \, -, and ] need to be escaped.</value>
  </data>
  <data name="CheatSheetStar" xml:space="preserve">
    <value>Star</value>
  </data>
  <data name="CheatSheetStarDetails" xml:space="preserve">
    <value>Matches 0 or more of the preceding token.</value>
  </data>
  <data name="CheatSheetStrictEndOfString" xml:space="preserve">
    <value>Strict end of string</value>
  </data>
  <data name="CheatSheetStrictEndOfStringDetails" xml:space="preserve">
    <value>Matches the end of the string. Unlike $ or \Z, it does not allow for a trailing newline. This is unaffected by the multiline flag (m). This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetSyntax" xml:space="preserve">
    <value>Syntax</value>
  </data>
  <data name="CheatSheetTab" xml:space="preserve">
    <value>Tab</value>
  </data>
  <data name="CheatSheetTabDetails" xml:space="preserve">
    <value>Matches a TAB character (char code 9).</value>
  </data>
  <data name="CheatSheetTitle" xml:space="preserve">
    <value>Cheat sheet</value>
  </data>
  <data name="CheatSheetUnicodeCategory" xml:space="preserve">
    <value>Unicode category</value>
  </data>
  <data name="CheatSheetUnicodeCategoryDetails" xml:space="preserve">
    <value>Matches a character in the specified unicode category. For example, \p{Ll} will match any lowercase letter.</value>
  </data>
  <data name="CheatSheetUnicodeEscape" xml:space="preserve">
    <value>Unicode escape</value>
  </data>
  <data name="CheatSheetUnicodeEscapeDetails" xml:space="preserve">
    <value>Unicode escaped character in the form \x{FF}.</value>
  </data>
  <data name="CheatSheetUnicodeGrapheme" xml:space="preserve">
    <value>Unicode grapheme</value>
  </data>
  <data name="CheatSheetUnicodeGraphemeDetails" xml:space="preserve">
    <value>Matches any single unicode grapheme (ie. character). This includes line breaks (regardless of the dotall mode) and graphemes encoded as multiple code points.</value>
  </data>
  <data name="CheatSheetUnicodeScript" xml:space="preserve">
    <value>Unicode script</value>
  </data>
  <data name="CheatSheetUnicodeScriptDetails" xml:space="preserve">
    <value>Matches any character in the specified unicode script. For example, \p{Arabic} will match characters in the Arabic script.</value>
  </data>
  <data name="CheatSheetVerticalWhitespace" xml:space="preserve">
    <value>Vertical whitespace</value>
  </data>
  <data name="CheatSheetVerticalWhitespaceDetails" xml:space="preserve">
    <value>Matches any vertical whitespace character (line breaks).</value>
  </data>
  <data name="CheatSheetWhitespace" xml:space="preserve">
    <value>Whitespace</value>
  </data>
  <data name="CheatSheetWhitespaceDetails" xml:space="preserve">
    <value>Matches any whitespace character (spaces, tabs, line breaks).</value>
  </data>
  <data name="CheatSheetWord" xml:space="preserve">
    <value>Word</value>
  </data>
  <data name="CheatSheetWordBoundary" xml:space="preserve">
    <value>Word boundary</value>
  </data>
  <data name="CheatSheetWordBoundaryDetails" xml:space="preserve">
    <value>Matches a word boundary position between a word character and non-word character or position (start / end of string). See the word character class (w) for more info.</value>
  </data>
  <data name="CheatSheetWordDetails" xml:space="preserve">
    <value>Matches any word character (alphanumeric &amp; underscore). Only matches low-ascii characters (no accented or non-roman characters). Equivalent to [A-Za-z0-9_]</value>
  </data>
  <data name="Configuration" xml:space="preserve">
    <value>Konfigurace</value>
  </data>
  <data name="CultureInvariant" xml:space="preserve">
    <value>Culture Invariant</value>
  </data>
  <data name="CultureInvariantDescription" xml:space="preserve">
    <value>Specifies that cultural differences in language is ignored.</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Validate and test regular expressions</value>
  </data>
  <data name="EcmaScript" xml:space="preserve">
    <value>ECMA Script</value>
  </data>
  <data name="EcmaScriptDescription" xml:space="preserve">
    <value>Enables ECMAScript-compliant behavior for the expression. This value can be used only in conjunction with the Culture Invariant, Ignore Case and Multiline options.</value>
  </data>
  <data name="IgnoreCase" xml:space="preserve">
    <value>Ignore Case</value>
  </data>
  <data name="IgnoreCaseDescription" xml:space="preserve">
    <value>Specifies case-insensitive matching.</value>
  </data>
  <data name="IgnoreWhitespace" xml:space="preserve">
    <value>Ignore Whitespace</value>
  </data>
  <data name="IgnoreWhitespaceDescription" xml:space="preserve">
    <value>Eliminates unescaped white space from the pattern and enables comments marked with #. However, this value does not affect or eliminate white space in character classes, numeric quantifiers, or tokens that mark the beginning of individual regular expression language elements.</value>
  </data>
  <data name="LongDisplayTitle" xml:space="preserve">
    <value>Regular Expression Tester</value>
  </data>
  <data name="MatchGroupPrefix" xml:space="preserve">
    <value>Group</value>
  </data>
  <data name="MatchInformation" xml:space="preserve">
    <value>Match information</value>
  </data>
  <data name="MatchLocation" xml:space="preserve">
    <value>Location</value>
  </data>
  <data name="MatchName" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="MatchNamePrefix" xml:space="preserve">
    <value>Match</value>
  </data>
  <data name="MatchValue" xml:space="preserve">
    <value>Value</value>
  </data>
  <data name="Multiline" xml:space="preserve">
    <value>Multiline</value>
  </data>
  <data name="MultilineDescription" xml:space="preserve">
    <value>Changes the meaning of ^ and $ so they match at the beginning and end, respectively, of any line, and not just the beginning and end of the entire string.</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>Options</value>
  </data>
  <data name="RegularExpression" xml:space="preserve">
    <value>Regular expression</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>Right To Left</value>
  </data>
  <data name="RightToLeftDescription" xml:space="preserve">
    <value>Specifies that the search will be from right to left instead of from left to right.</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value>regular expression</value>
  </data>
  <data name="ShortDisplayTitle" xml:space="preserve">
    <value>RegEx</value>
  </data>
  <data name="Singleline" xml:space="preserve">
    <value>Singleline</value>
  </data>
  <data name="SinglelineDescription" xml:space="preserve">
    <value>Changes the meaning of the dot (.) so it matches every character (instead of every character except \n).</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>Text</value>
  </data>
</root>