<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>正则表达式测试工具</value>
  </data>
  <data name="AllMatches" xml:space="preserve">
    <value>全部匹配</value>
  </data>
  <data name="AllMatchesDescription" xml:space="preserve">
    <value>Find all the matches in the text or stop after the first match.</value>
  </data>
  <data name="CheatSheetAlternation" xml:space="preserve">
    <value>Alternation</value>
  </data>
  <data name="CheatSheetAlternationDetails" xml:space="preserve">
    <value>Acts like a boolean OR. Matches the expression before or after the |.
It can operate within a group, or on a whole expression. The patterns will be tested in order.</value>
  </data>
  <data name="CheatSheetAnyCharacter" xml:space="preserve">
    <value>Any character except newline</value>
  </data>
  <data name="CheatSheetAnyCharacterDetails" xml:space="preserve">
    <value>Matches any character other than newline. Equivalent to [^\n\r].</value>
  </data>
  <data name="CheatSheetAtomicGroup" xml:space="preserve">
    <value>Atomic group</value>
  </data>
  <data name="CheatSheetAtomicGroupDetails" xml:space="preserve">
    <value>Non-capturing group that discards backtracking positions once matched.
For example, /(?&gt;ab|a)b/ will match abb but not ab because once the ab option has matched, the atomic group prevents backtracking to retry with the a option.</value>
  </data>
  <data name="CheatSheetBeginning" xml:space="preserve">
    <value>Beginning</value>
  </data>
  <data name="CheatSheetBeginningDetails" xml:space="preserve">
    <value>Matches the beginning of the string, or the beginning of a line if the multiline flag (m) is enabled. This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetBeginningOfString" xml:space="preserve">
    <value>Beginning of string</value>
  </data>
  <data name="CheatSheetBeginningOfStringDetails" xml:space="preserve">
    <value>Matches the beginning of the string. Unlike ^, this is unaffected by the multiline flag (m). This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetBell" xml:space="preserve">
    <value>Bell</value>
  </data>
  <data name="CheatSheetBellDetails" xml:space="preserve">
    <value>匹配一个 BELL 字符（码表7）。</value>
  </data>
  <data name="CheatSheetBranchResetGroup" xml:space="preserve">
    <value>Branch reset group</value>
  </data>
  <data name="CheatSheetBranchResetGroupDetails" xml:space="preserve">
    <value>Define alternative groups that share the same group numbers.
For example, in (?|(a)|(b)) both groups (a and b) would be counted as group #1.</value>
  </data>
  <data name="CheatSheetCaptureGroup" xml:space="preserve">
    <value>捕获组</value>
  </data>
  <data name="CheatSheetCaptureGroupDetails" xml:space="preserve">
    <value>Inserts the results of the specified capture group. For example, $3 would insert the third capture group.
There are multiple syntaxes for this feature:

$1 \1 \{1}</value>
  </data>
  <data name="CheatSheetCapturingGroup" xml:space="preserve">
    <value>捕获组</value>
  </data>
  <data name="CheatSheetCapturingGroupDetails" xml:space="preserve">
    <value>Groups multiple tokens together and creates a capture group for extracting a substring or using a backreference.</value>
  </data>
  <data name="CheatSheetCarriageReturn" xml:space="preserve">
    <value>回车符</value>
  </data>
  <data name="CheatSheetCarriageReturnDetails" xml:space="preserve">
    <value>Matches a CARRIAGE RETURN character (char code 13).</value>
  </data>
  <data name="CheatSheetCategoryAnchors" xml:space="preserve">
    <value>Anchors</value>
  </data>
  <data name="CheatSheetCategoryCharacterClasses" xml:space="preserve">
    <value>Character classes</value>
  </data>
  <data name="CheatSheetCategoryEscapedCharacters" xml:space="preserve">
    <value>Escaped characters</value>
  </data>
  <data name="CheatSheetCategoryGroupsReferences" xml:space="preserve">
    <value>Groups and References</value>
  </data>
  <data name="CheatSheetCategoryLookaround" xml:space="preserve">
    <value>Lookaround</value>
  </data>
  <data name="CheatSheetCategoryQuantifiersAlternation" xml:space="preserve">
    <value>Quantifiers and Alternation</value>
  </data>
  <data name="CheatSheetCategorySpecial" xml:space="preserve">
    <value>Special</value>
  </data>
  <data name="CheatSheetCategorySubstitution" xml:space="preserve">
    <value>Substitution</value>
  </data>
  <data name="CheatSheetCharacterRange" xml:space="preserve">
    <value>Character range</value>
  </data>
  <data name="CheatSheetCharacterRangeDetails" xml:space="preserve">
    <value>Matches a character having a character code between the two specified characters inclusive.</value>
  </data>
  <data name="CheatSheetCharacterSet" xml:space="preserve">
    <value>A single character of A, b or c</value>
  </data>
  <data name="CheatSheetCharacterSetDetails" xml:space="preserve">
    <value>Matches either an A, b or c character</value>
  </data>
  <data name="CheatSheetComment" xml:space="preserve">
    <value>注释</value>
  </data>
  <data name="CheatSheetCommentDetails" xml:space="preserve">
    <value>Allows you to insert a comment into your expression that is ignored when finding a match.</value>
  </data>
  <data name="CheatSheetConditional" xml:space="preserve">
    <value>Conditional</value>
  </data>
  <data name="CheatSheetConditionalDetails" xml:space="preserve">
    <value>Conditionally matches one of two options based on whether a lookaround is matched.
For example, /(?(?=a)ab|..)/ will match ab and zx but not ax, because if the first character matches the condition a then it evaluates the pattern ab.

Any lookaround can be used as the condition. A lookahead will start the subsequent match at the start of the condition, a lookbehind will start it after.</value>
  </data>
  <data name="CheatSheetControlCharacterEscape" xml:space="preserve">
    <value>Control character escape</value>
  </data>
  <data name="CheatSheetControlCharacterEscapeDetails" xml:space="preserve">
    <value>Escaped control character in the form \cZ. This can range from \cA (SOH, char code 1) to \cZ (SUB, char code 26).</value>
  </data>
  <data name="CheatSheetDefine" xml:space="preserve">
    <value>Define</value>
  </data>
  <data name="CheatSheetDefineDetails" xml:space="preserve">
    <value>Used to define named groups for use as subroutines without including them in the match.
For example, /A(?(DEFINE)(?'foo'Z))B\g'foo'/ will match ABZ, because the define group is ignored in the match except to define the foo subroutine that is referenced later with \g'foo'.</value>
  </data>
  <data name="CheatSheetDescription" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="CheatSheetDigit" xml:space="preserve">
    <value>Digit</value>
  </data>
  <data name="CheatSheetDigitDetails" xml:space="preserve">
    <value>Matches any digit character (0-9). Equivalent to [0-9].</value>
  </data>
  <data name="CheatSheetEnd" xml:space="preserve">
    <value>End</value>
  </data>
  <data name="CheatSheetEndDetails" xml:space="preserve">
    <value>Matches the end of the string, or the end of a line if the multiline flag (m) is enabled. This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetEndOfString" xml:space="preserve">
    <value>End of string</value>
  </data>
  <data name="CheatSheetEndOfStringDetails" xml:space="preserve">
    <value>Matches the end of the string. Unlike $, this is unaffected by the multiline flag (m). This matches a position, not a character.</value>
  </data>
  <data name="CheatSheetEsc" xml:space="preserve">
    <value>Esc</value>
  </data>
  <data name="CheatSheetEscapedCharacters" xml:space="preserve">
    <value>Escaped characters</value>
  </data>
  <data name="CheatSheetEscapedCharactersDetails" xml:space="preserve">
    <value>For convenience, these escaped characters are supported in the Replace string in RegExr: \n, \r, \t, \\, and unicode escapes \uFFFF. This may vary in your deploy environment.</value>
  </data>
  <data name="CheatSheetEscapeSequence" xml:space="preserve">
    <value>Escape sequence</value>
  </data>
  <data name="CheatSheetEscapeSequenceDetails" xml:space="preserve">
    <value>All characters between the \Q and the \E are interpreted as a literal string. If \E is omitted, it continues to the end of the expression. For example, the expression /\Q(?.)\E/ will match the string (?.).</value>
  </data>
  <data name="CheatSheetEscDetails" xml:space="preserve">
    <value>Matches a ESC character (char code 27).</value>
  </data>
  <data name="CheatSheetFormFeed" xml:space="preserve">
    <value>Form feed</value>
  </data>
  <data name="CheatSheetFormFeedDetails" xml:space="preserve">
    <value>Matches a FORM FEED character (char code 12).</value>
  </data>
  <data name="CheatSheetGroupConditional" xml:space="preserve">
    <value>Group conditional</value>
  </data>
  <data name="CheatSheetGroupConditionalDetails" xml:space="preserve">
    <value>Conditionally matches one of two options based on whether group 'undefined' matched.
For example, /(z)?(?(1)a|b)/ will match za because the first capture group matches z successfully, which causes the conditional to match the first option a.

The same pattern will also match b on its own, because group 1 doesn't match, so it instead tries to match the second option b.

You can reference a group by name, number, or relative position (ex. -1).</value>
  </data>
  <data name="CheatSheetHexadecimalEscape" xml:space="preserve">
    <value>Hexadecimal escape</value>
  </data>
  <data name="CheatSheetHexadecimalEscapeDetails" xml:space="preserve">
    <value>Hexadecimal escaped character in the form \xFF.</value>
  </data>
  <data name="CheatSheetHorizontalWhitespace" xml:space="preserve">
    <value>Horizontal whitespace</value>
  </data>
  <data name="CheatSheetHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Matches any horizontal whitespace character (spaces, tabs).</value>
  </data>
  <data name="CheatSheetKeepOut" xml:space="preserve">
    <value>Keep out</value>
  </data>
  <data name="CheatSheetKeepOutDetails" xml:space="preserve">
    <value>Keep text matched so far out of the returned match, essentially discarding the match up to this point.For example /o\Kbar/ will match bar within the string foobar</value>
  </data>
  <data name="CheatSheetLazy" xml:space="preserve">
    <value>Lazy</value>
  </data>
  <data name="CheatSheetLazyDetails" xml:space="preserve">
    <value>Makes the preceding quantifier lazy, causing it to match as few characters as possible. By default, quantifiers are greedy, and will match as many characters as possible.
This behaviour is reversed by the ungreedy (U) flag/modifier.</value>
  </data>
  <data name="CheatSheetLineBreak" xml:space="preserve">
    <value>Line break</value>
  </data>
  <data name="CheatSheetLineBreakDetails" xml:space="preserve">
    <value>Matches any line break character, including the CRLF pair, and CR / LF individually.</value>
  </data>
  <data name="CheatSheetLineFeed" xml:space="preserve">
    <value>Line feed</value>
  </data>
  <data name="CheatSheetLineFeedDetails" xml:space="preserve">
    <value>Matches a LINE FEED character (char code 10).</value>
  </data>
  <data name="CheatSheetMatch" xml:space="preserve">
    <value>Match</value>
  </data>
  <data name="CheatSheetMatchAny" xml:space="preserve">
    <value>Match any</value>
  </data>
  <data name="CheatSheetMatchAnyDetails" xml:space="preserve">
    <value>A character set that can be used to match any character, including line breaks, without the dotall flag (s).</value>
  </data>
  <data name="CheatSheetMatchDetails" xml:space="preserve">
    <value>Inserts the matched text.
There are multiple syntaxes for this feature:

$0 \0 \{0}</value>
  </data>
  <data name="CheatSheetModeModifier" xml:space="preserve">
    <value>Mode modifier</value>
  </data>
  <data name="CheatSheetModeModifierDetails" xml:space="preserve">
    <value>Enables or disables modes for the remainder of the expression.Matching modes generally map to expression flags. For example (?i) would enable case insensitivity for the remainder of the expression.
Multiple modifiers can be specified, and any modifiers that follow - are disabled. For example (?im-s) would enable case insensitivity &amp; multiline modes, and disable dotall.

Supported modifiers are: i - case insensitive, s - dotall, m - multiline, x - free spacing, J - allow duplicate names, U - ungreedy.</value>
  </data>
  <data name="CheatSheetNamedCapturingGroup" xml:space="preserve">
    <value>Named capturing group</value>
  </data>
  <data name="CheatSheetNamedCapturingGroupDetails" xml:space="preserve">
    <value>Creates a capturing group that can be referenced via the specified name.
There are multiple syntaxes for this feature:

(?'name'ABC) (?P&lt;name&gt;ABC) (?&lt;name&gt;ABC)</value>
  </data>
  <data name="CheatSheetNamedReference" xml:space="preserve">
    <value>Named reference</value>
  </data>
  <data name="CheatSheetNamedReferenceDetails" xml:space="preserve">
    <value>Matches the results of a named capture group.
There are multiple syntaxes for this feature:

\k'name' \k&lt;name&gt; \k{name} \g{name} (?P=name)</value>
  </data>
  <data name="CheatSheetNamedSubroutine" xml:space="preserve">
    <value>Named subroutine</value>
  </data>
  <data name="CheatSheetNamedSubroutineDetails" xml:space="preserve">
    <value>Matches the expression in a capture group. Compare this to a reference, that matches the result.
There are multiple syntaxes for this feature: \g&lt;name&gt; \g'name' (?&amp;name) (?P&gt;name).</value>
  </data>
  <data name="CheatSheetNegatedCharacterSet" xml:space="preserve">
    <value>A、b 或 c 之外的字符</value>
  </data>
  <data name="CheatSheetNegatedCharacterSetDetails" xml:space="preserve">
    <value>匹配任何 A、b 或 c 之外的字符。</value>
  </data>
  <data name="CheatSheetNegativeLookahead" xml:space="preserve">
    <value>负向先行断言</value>
  </data>
  <data name="CheatSheetNegativeLookaheadDetails" xml:space="preserve">
    <value>指定无法匹配主表达式之后内容的组（如果匹配则丢弃结果）。</value>
  </data>
  <data name="CheatSheetNegativeLookbehind" xml:space="preserve">
    <value>负向后行断言</value>
  </data>
  <data name="CheatSheetNegativeLookbehindDetails" xml:space="preserve">
    <value>指定无法匹配主表达式之前内容的组（如果匹配则丢弃结果）。</value>
  </data>
  <data name="CheatSheetNonCapturingGroup" xml:space="preserve">
    <value>非捕获组</value>
  </data>
  <data name="CheatSheetNonCapturingGroupDetails" xml:space="preserve">
    <value>组合多个词元而不创建捕获组。</value>
  </data>
  <data name="CheatSheetNotDigit" xml:space="preserve">
    <value>非数字</value>
  </data>
  <data name="CheatSheetNotDigitDetails" xml:space="preserve">
    <value>匹配任何数字字符（0-9）之外的字符。等价于 [^0-9]。</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespace" xml:space="preserve">
    <value>非水平空白符</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespaceDetails" xml:space="preserve">
    <value>匹配任何水平空白符（空格、制表符）之外的字符。</value>
  </data>
  <data name="CheatSheetNotLineBreak" xml:space="preserve">
    <value>非换行</value>
  </data>
  <data name="CheatSheetNotLineBreakDetails" xml:space="preserve">
    <value>匹配任何换行之外的字符。与点语法（.）类似，但不受 dotAll 标志影响。</value>
  </data>
  <data name="CheatSheetNotUnicodeCategory" xml:space="preserve">
    <value>非 Unicode 分类</value>
  </data>
  <data name="CheatSheetNotUnicodeCategoryDetails" xml:space="preserve">
    <value>匹配任何不在特定的 Unicode 分类中的字符。</value>
  </data>
  <data name="CheatSheetNotUnicodeScript" xml:space="preserve">
    <value>非 Unicode 文种</value>
  </data>
  <data name="CheatSheetNotUnicodeScriptDetails" xml:space="preserve">
    <value>匹配任何不在特定的 Unicode 文种中的字符。</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespace" xml:space="preserve">
    <value>非垂直空白符</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespaceDetails" xml:space="preserve">
    <value>匹配任何垂直空白符（换行）之外的字符。</value>
  </data>
  <data name="CheatSheetNotWhitespace" xml:space="preserve">
    <value>非空白符</value>
  </data>
  <data name="CheatSheetNotWhitespaceDetails" xml:space="preserve">
    <value>匹配任何空白符（空格、制表符、换行）之外的字符。</value>
  </data>
  <data name="CheatSheetNotWord" xml:space="preserve">
    <value>非字词</value>
  </data>
  <data name="CheatSheetNotWordBoundary" xml:space="preserve">
    <value>非字词边界</value>
  </data>
  <data name="CheatSheetNotWordBoundaryDetails" xml:space="preserve">
    <value>匹配任何字词边界之外的位置。匹配结果是字符位置而非字符本身。</value>
  </data>
  <data name="CheatSheetNotWordDetails" xml:space="preserve">
    <value>匹配任何字词字符（字母和下划线）之外的字符。等价于 [^A-Za-z0-9_]</value>
  </data>
  <data name="CheatSheetNull" xml:space="preserve">
    <value>Null</value>
  </data>
  <data name="CheatSheetNullDetails" xml:space="preserve">
    <value>匹配 NULL 字符（字符码位值为 0）。</value>
  </data>
  <data name="CheatSheetNumericReference" xml:space="preserve">
    <value>Numeric reference</value>
  </data>
  <data name="CheatSheetNumericReferenceDetails" xml:space="preserve">
    <value>Matches the results of a capture group. For example \1 matches the results of the first capture group &amp; \3 matches the third.
There are multiple syntaxes for this feature: \1 \g1 \g{1}.

The latter syntaxes support relative values preceded by + or -. For example \g-1 would match the group preceding the reference.</value>
  </data>
  <data name="CheatSheetNumericSubroutine" xml:space="preserve">
    <value>Numeric subroutine</value>
  </data>
  <data name="CheatSheetNumericSubroutineDetails" xml:space="preserve">
    <value>Matches the expression in a capture group. Compare this to a reference, that matches the result. For example /(a|b)\g'1'/ can match ab, because the expression a|b is evaluated again.
There are multiple syntaxes for this feature: \g&lt;1&gt; \g'1' (?1).

Relative values preceded by + or - are also supported. For example \g&lt;-1&gt; would match the group preceding the reference.</value>
  </data>
  <data name="CheatSheetOctalEscape" xml:space="preserve">
    <value>八进制转义</value>
  </data>
  <data name="CheatSheetOctalEscapeDetails" xml:space="preserve">
    <value>以 \000 形式表示的八进制转义字符。值必须小于 255 (\377)。
同时支持 \o{FFF} 语法。</value>
  </data>
  <data name="CheatSheetOptional" xml:space="preserve">
    <value>可选</value>
  </data>
  <data name="CheatSheetOptionalDetails" xml:space="preserve">
    <value>匹配 0 个或 1 个前文词元，效果为使其非必要出现。</value>
  </data>
  <data name="CheatSheetPlus" xml:space="preserve">
    <value>加号</value>
  </data>
  <data name="CheatSheetPlusDetails" xml:space="preserve">
    <value>匹配 1 个或更多个前文词元。</value>
  </data>
  <data name="CheatSheetPositiveLookahead" xml:space="preserve">
    <value>正向先行断言</value>
  </data>
  <data name="CheatSheetPositiveLookaheadDetails" xml:space="preserve">
    <value>匹配主表达式之后的组，但结果不包含匹配内容。</value>
  </data>
  <data name="CheatSheetPositiveLookbehind" xml:space="preserve">
    <value>正向后行断言</value>
  </data>
  <data name="CheatSheetPositiveLookbehindDetails" xml:space="preserve">
    <value>匹配主表达式之前的组，但结果不包含匹配内容。</value>
  </data>
  <data name="CheatSheetPossessive" xml:space="preserve">
    <value>贪婪模式</value>
  </data>
  <data name="CheatSheetPossessiveDetails" xml:space="preserve">
    <value>使前文量词贪婪。使其匹配尽可能多的字符，且不会匹配后续词元。
例如 /.*a/ 会匹配 aaa，而 /.*+a/ 则不会，因为表示重复的点语法在匹配时不会再释放出最后的字符以供表达式中的 a 匹配。</value>
  </data>
  <data name="CheatSheetPreviousMatchEnd" xml:space="preserve">
    <value>上一次匹配末尾</value>
  </data>
  <data name="CheatSheetPreviousMatchEndDetails" xml:space="preserve">
    <value>匹配上一次匹配的末尾位置。匹配结果是字符位置而非字符本身。</value>
  </data>
  <data name="CheatSheetQuantifier" xml:space="preserve">
    <value>量词</value>
  </data>
  <data name="CheatSheetQuantifierDetails" xml:space="preserve">
    <value>匹配指定数量的前文词元。{1,3} 会匹配 1 到 3。{3} 会精确匹配 3，{3,} 会匹配 3 以及以上</value>
  </data>
  <data name="CheatSheetRecursion" xml:space="preserve">
    <value>递归</value>
  </data>
  <data name="CheatSheetRecursionDetails" xml:space="preserve">
    <value>尝试在当前位置再次匹配整个表达式。
例如，/a(?R)?b/ 将匹配任意个 a 以及其后相同数量的 z：匹配 az 或 aaaazzzz，但不会匹配 azzz。

此功能有多个语法：

(?R) (?0) \g&lt;0&gt; \g'0'</value>
  </data>
  <data name="CheatSheetReservedCharacters" xml:space="preserve">
    <value>保留字符</value>
  </data>
  <data name="CheatSheetReservedCharactersDetails" xml:space="preserve">
    <value>以下字符具有特殊含义，应该在其前面使用 \（反斜杠）来表示字符本身：
+*?^$\.[]{}()|/

在字符集合中，只有 \、- 和 ] 需要进行转义。</value>
  </data>
  <data name="CheatSheetStar" xml:space="preserve">
    <value>星号</value>
  </data>
  <data name="CheatSheetStarDetails" xml:space="preserve">
    <value>匹配 0 个或更多个前文词元。</value>
  </data>
  <data name="CheatSheetStrictEndOfString" xml:space="preserve">
    <value>严格字符串末尾</value>
  </data>
  <data name="CheatSheetStrictEndOfStringDetails" xml:space="preserve">
    <value>匹配字符串的末尾。与 $ 或 \Z 不同，它不允许尾随换行符，且不受多行标志（m）影响。匹配结果是字符位置而非字符本身。</value>
  </data>
  <data name="CheatSheetSyntax" xml:space="preserve">
    <value>语法</value>
  </data>
  <data name="CheatSheetTab" xml:space="preserve">
    <value>Tab</value>
  </data>
  <data name="CheatSheetTabDetails" xml:space="preserve">
    <value>匹配 TAB 字符（字符码位值为 9）。</value>
  </data>
  <data name="CheatSheetTitle" xml:space="preserve">
    <value>速查表</value>
  </data>
  <data name="CheatSheetUnicodeCategory" xml:space="preserve">
    <value>Unicode 分类</value>
  </data>
  <data name="CheatSheetUnicodeCategoryDetails" xml:space="preserve">
    <value>匹配在特定的 Unicode 分类中的字符。例如，\p{Ll} 会匹配任意小写字母。</value>
  </data>
  <data name="CheatSheetUnicodeEscape" xml:space="preserve">
    <value>Unicode 转义</value>
  </data>
  <data name="CheatSheetUnicodeEscapeDetails" xml:space="preserve">
    <value>以 \x{FF} 形式表示的 Unicode 转义字符。</value>
  </data>
  <data name="CheatSheetUnicodeGrapheme" xml:space="preserve">
    <value>Unicode 字素</value>
  </data>
  <data name="CheatSheetUnicodeGraphemeDetails" xml:space="preserve">
    <value>匹配任何单一的 Unicode 字素（如字符）。包括换行（不论是否为 dotAll 模式）以及编码占据多个码点的字素。</value>
  </data>
  <data name="CheatSheetUnicodeScript" xml:space="preserve">
    <value>Unicode 文种</value>
  </data>
  <data name="CheatSheetUnicodeScriptDetails" xml:space="preserve">
    <value>匹配任何特定的 Unicode 文种字符。例如，\p{Arabic} 会匹配阿拉伯文种字符。</value>
  </data>
  <data name="CheatSheetVerticalWhitespace" xml:space="preserve">
    <value>垂直空白符</value>
  </data>
  <data name="CheatSheetVerticalWhitespaceDetails" xml:space="preserve">
    <value>匹配任何垂直空白符（换行）。</value>
  </data>
  <data name="CheatSheetWhitespace" xml:space="preserve">
    <value>空白符</value>
  </data>
  <data name="CheatSheetWhitespaceDetails" xml:space="preserve">
    <value>匹配任何空白字符（空格、制表符、换行）。</value>
  </data>
  <data name="CheatSheetWord" xml:space="preserve">
    <value>字词</value>
  </data>
  <data name="CheatSheetWordBoundary" xml:space="preserve">
    <value>字词边界</value>
  </data>
  <data name="CheatSheetWordBoundaryDetails" xml:space="preserve">
    <value>匹配字词字符和非字词字符或位置之间的字词边界位置，即字符串的起始和末尾。请参阅字词字符类（w）以了解更多信息。</value>
  </data>
  <data name="CheatSheetWordDetails" xml:space="preserve">
    <value>匹配任何字词字符（字母和下划线）。仅匹配低位 ASCII 字符（不带重音符号或非罗马字符）。等价于 [A-Za-z0-9_]</value>
  </data>
  <data name="Configuration" xml:space="preserve">
    <value>配置</value>
  </data>
  <data name="CultureInvariant" xml:space="preserve">
    <value>区域性不变</value>
  </data>
  <data name="CultureInvariantDescription" xml:space="preserve">
    <value>指定忽略语言中的区域性差异。</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>验证和测试正则表达式</value>
  </data>
  <data name="EcmaScript" xml:space="preserve">
    <value>ECMA Script</value>
  </data>
  <data name="EcmaScriptDescription" xml:space="preserve">
    <value>为表达式启用符合 ECMAScript 的行为。此选项只能与区域性不变、忽略大小写和多行选项一起使用。</value>
  </data>
  <data name="IgnoreCase" xml:space="preserve">
    <value>忽略大小写</value>
  </data>
  <data name="IgnoreCaseDescription" xml:space="preserve">
    <value>指定不区分大小写的匹配。</value>
  </data>
  <data name="IgnoreWhitespace" xml:space="preserve">
    <value>忽略空白符</value>
  </data>
  <data name="IgnoreWhitespaceDescription" xml:space="preserve">
    <value>消除模式中未转义的空格，并启用以 # 标记的注释。但是，此选项不会影响或消除标记单独的正则表达式语言元素开头的字符类、数值量词或词元的空格。</value>
  </data>
  <data name="LongDisplayTitle" xml:space="preserve">
    <value>正则表达式测试工具</value>
  </data>
  <data name="MatchGroupPrefix" xml:space="preserve">
    <value>组</value>
  </data>
  <data name="MatchInformation" xml:space="preserve">
    <value>匹配信息</value>
  </data>
  <data name="MatchLocation" xml:space="preserve">
    <value>位置</value>
  </data>
  <data name="MatchName" xml:space="preserve">
    <value>名称</value>
  </data>
  <data name="MatchNamePrefix" xml:space="preserve">
    <value>匹配</value>
  </data>
  <data name="MatchValue" xml:space="preserve">
    <value>值</value>
  </data>
  <data name="Multiline" xml:space="preserve">
    <value>多行模式</value>
  </data>
  <data name="MultilineDescription" xml:space="preserve">
    <value>改变^和$的含义，使它们分别匹配任意行的开头和结尾，而不是仅匹配整个字符串的开头和结尾。</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>选项</value>
  </data>
  <data name="RegularExpression" xml:space="preserve">
    <value>正则表达式</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>从右到左模式</value>
  </data>
  <data name="RightToLeftDescription" xml:space="preserve">
    <value>指定搜索方向为从右到左，而非从左到右。</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value>正则表达式</value>
  </data>
  <data name="ShortDisplayTitle" xml:space="preserve">
    <value>正则表达式</value>
  </data>
  <data name="Singleline" xml:space="preserve">
    <value>单行模式</value>
  </data>
  <data name="SinglelineDescription" xml:space="preserve">
    <value>更改点 (.) 的含义，以使它与每个字符（而不是除 \n 之外的所有字符）匹配。</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>文本</value>
  </data>
</root>