<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Ferramenta de Teste de Expressões Regulares</value>
  </data>
  <data name="AllMatches" xml:space="preserve">
    <value>Todas as correspondências</value>
  </data>
  <data name="AllMatchesDescription" xml:space="preserve">
    <value>Encontre todas as correspondências no texto ou pare após a primeira correspondência.</value>
  </data>
  <data name="CheatSheetAlternation" xml:space="preserve">
    <value>Alternância</value>
  </data>
  <data name="CheatSheetAlternationDetails" xml:space="preserve">
    <value>Atua como um OU booleano. Corresponde à expressão antes ou depois de |.
Pode operar dentro de um grupo ou em uma expressão inteira. Os padrões serão testados em ordem.</value>
  </data>
  <data name="CheatSheetAnyCharacter" xml:space="preserve">
    <value>Qualquer caractere, exceto nova linha</value>
  </data>
  <data name="CheatSheetAnyCharacterDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere diferente de nova linha. Equivalente a [^\n\r].</value>
  </data>
  <data name="CheatSheetAtomicGroup" xml:space="preserve">
    <value>Grupo atômico</value>
  </data>
  <data name="CheatSheetAtomicGroupDetails" xml:space="preserve">
    <value>Grupo sem captura que descarta posições de retrocesso uma vez correspondidas.
Por exemplo, /(?&gt;ab|a)b/ corresponderá a abb, mas não ab porque, uma vez que a opção ab tenha correspondido, o grupo atômico impede o retrocesso para tentar novamente com a opção a.</value>
  </data>
  <data name="CheatSheetBeginning" xml:space="preserve">
    <value>Início</value>
  </data>
  <data name="CheatSheetBeginningDetails" xml:space="preserve">
    <value>Corresponde ao início da string ou ao início de uma linha se o sinalizador de várias linhas (m) estiver ativado. Isso corresponde a uma posição, não a um caractere.</value>
  </data>
  <data name="CheatSheetBeginningOfString" xml:space="preserve">
    <value>Início da string</value>
  </data>
  <data name="CheatSheetBeginningOfStringDetails" xml:space="preserve">
    <value>Corresponde ao início da string. Ao contrário de ^, isso não é afetado pelo sinalizador de várias linhas (m). Isso corresponde a uma posição, não a um caractere.</value>
  </data>
  <data name="CheatSheetBell" xml:space="preserve">
    <value>Sino</value>
  </data>
  <data name="CheatSheetBellDetails" xml:space="preserve">
    <value>Corresponde a um caractere BELL (código de caractere 7).</value>
  </data>
  <data name="CheatSheetBranchResetGroup" xml:space="preserve">
    <value>Grupo de redefinição de ramificação</value>
  </data>
  <data name="CheatSheetBranchResetGroupDetails" xml:space="preserve">
    <value>Define grupos alternativos que compartilham os mesmos números de grupo.
Por exemplo, em (?|(a)|(b)), ambos os grupos (a e b) seriam contados como grupo nº 1.</value>
  </data>
  <data name="CheatSheetCaptureGroup" xml:space="preserve">
    <value>Grupo de captura</value>
  </data>
  <data name="CheatSheetCaptureGroupDetails" xml:space="preserve">
    <value>Insere os resultados do grupo de captura especificado. Por exemplo, $3 inseriria o terceiro grupo de captura.
Existem várias sintaxes para este recurso:

$1 \1 \{1}</value>
  </data>
  <data name="CheatSheetCapturingGroup" xml:space="preserve">
    <value>Grupo de captura</value>
  </data>
  <data name="CheatSheetCapturingGroupDetails" xml:space="preserve">
    <value>Agrupa vários tokens e cria um grupo de captura para extrair uma substring ou usar uma referência inversa.</value>
  </data>
  <data name="CheatSheetCarriageReturn" xml:space="preserve">
    <value>Retorno de carro</value>
  </data>
  <data name="CheatSheetCarriageReturnDetails" xml:space="preserve">
    <value>Corresponde a um caractere CARRIAGE RETURN (código de caractere 13).</value>
  </data>
  <data name="CheatSheetCategoryAnchors" xml:space="preserve">
    <value>Âncoras</value>
  </data>
  <data name="CheatSheetCategoryCharacterClasses" xml:space="preserve">
    <value>Classes de caracteres</value>
  </data>
  <data name="CheatSheetCategoryEscapedCharacters" xml:space="preserve">
    <value>Caracteres com escape</value>
  </data>
  <data name="CheatSheetCategoryGroupsReferences" xml:space="preserve">
    <value>Grupos e Referências</value>
  </data>
  <data name="CheatSheetCategoryLookaround" xml:space="preserve">
    <value>Olhar ao redor</value>
  </data>
  <data name="CheatSheetCategoryQuantifiersAlternation" xml:space="preserve">
    <value>Quantificadores e Alternância</value>
  </data>
  <data name="CheatSheetCategorySpecial" xml:space="preserve">
    <value>Especial</value>
  </data>
  <data name="CheatSheetCategorySubstitution" xml:space="preserve">
    <value>Substituição</value>
  </data>
  <data name="CheatSheetCharacterRange" xml:space="preserve">
    <value>Intervalo de caracteres</value>
  </data>
  <data name="CheatSheetCharacterRangeDetails" xml:space="preserve">
    <value>Corresponde a um caractere que possui um código de caractere entre os dois caracteres especificados, inclusive.</value>
  </data>
  <data name="CheatSheetCharacterSet" xml:space="preserve">
    <value>Um único caractere de A, b ou c</value>
  </data>
  <data name="CheatSheetCharacterSetDetails" xml:space="preserve">
    <value>Corresponde a um caractere A, b ou c</value>
  </data>
  <data name="CheatSheetComment" xml:space="preserve">
    <value>Comentário</value>
  </data>
  <data name="CheatSheetCommentDetails" xml:space="preserve">
    <value>Permite inserir um comentário em sua expressão que é ignorado ao encontrar uma correspondência.</value>
  </data>
  <data name="CheatSheetConditional" xml:space="preserve">
    <value>Condicional</value>
  </data>
  <data name="CheatSheetConditionalDetails" xml:space="preserve">
    <value>Corresponde condicionalmente a uma de duas opções com base em se um lookaround é correspondido.
Por exemplo, /(?(?=a)ab|..)/ corresponderá a ab e zx, mas não ax, porque se o primeiro caractere corresponder à condição a, ele avaliará o padrão ab.

Qualquer lookaround pode ser usado como condição. Um lookahead iniciará a correspondência subsequente no início da condição, um lookbehind a iniciará depois.</value>
  </data>
  <data name="CheatSheetControlCharacterEscape" xml:space="preserve">
    <value>Escape de caractere de controle</value>
  </data>
  <data name="CheatSheetControlCharacterEscapeDetails" xml:space="preserve">
    <value>Caractere de controle com escape no formato \cZ. Isso pode variar de \cA (SOH, código de caractere 1) a \cZ (SUB, código de caractere 26).</value>
  </data>
  <data name="CheatSheetDefine" xml:space="preserve">
    <value>Definir</value>
  </data>
  <data name="CheatSheetDefineDetails" xml:space="preserve">
    <value>Usado para definir grupos nomeados para uso como sub-rotinas sem incluí-los na correspondência.
Por exemplo, /A(?(DEFINE)(?'foo'Z))B\g'foo'/ corresponderá a ABZ, porque o grupo define é ignorado na correspondência, exceto para definir a sub-rotina foo que é referenciada posteriormente com \g'foo'.</value>
  </data>
  <data name="CheatSheetDescription" xml:space="preserve">
    <value>Descrição</value>
  </data>
  <data name="CheatSheetDigit" xml:space="preserve">
    <value>Dígito</value>
  </data>
  <data name="CheatSheetDigitDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere de dígito (0-9). Equivalente a [0-9].</value>
  </data>
  <data name="CheatSheetEnd" xml:space="preserve">
    <value>Fim</value>
  </data>
  <data name="CheatSheetEndDetails" xml:space="preserve">
    <value>Corresponde ao final da string ou ao final de uma linha se o sinalizador de várias linhas (m) estiver ativado. Isso corresponde a uma posição, não a um caractere.</value>
  </data>
  <data name="CheatSheetEndOfString" xml:space="preserve">
    <value>Fim da string</value>
  </data>
  <data name="CheatSheetEndOfStringDetails" xml:space="preserve">
    <value>Corresponde ao final da string. Ao contrário de $, isso não é afetado pelo sinalizador de várias linhas (m). Isso corresponde a uma posição, não a um caractere.</value>
  </data>
  <data name="CheatSheetEsc" xml:space="preserve">
    <value>Esc</value>
  </data>
  <data name="CheatSheetEscapedCharacters" xml:space="preserve">
    <value>Caracteres com escape</value>
  </data>
  <data name="CheatSheetEscapedCharactersDetails" xml:space="preserve">
    <value>Para conveniência, esses caracteres com escape são compatíveis na string Substituir em RegExr: \n, \r, \t, \\ e escapes unicode \uFFFF. Isso pode variar em seu ambiente de implantação.</value>
  </data>
  <data name="CheatSheetEscapeSequence" xml:space="preserve">
    <value>Sequência de escape</value>
  </data>
  <data name="CheatSheetEscapeSequenceDetails" xml:space="preserve">
    <value>Todos os caracteres entre \Q e \E são interpretados como uma string literal. Se \E for omitido, ele continua até o final da expressão. Por exemplo, a expressão /\Q(?.)\E/ corresponderá à string (?.).</value>
  </data>
  <data name="CheatSheetEscDetails" xml:space="preserve">
    <value>Corresponde a um caractere ESC (código de caractere 27).</value>
  </data>
  <data name="CheatSheetFormFeed" xml:space="preserve">
    <value>Alimentação de formulário</value>
  </data>
  <data name="CheatSheetFormFeedDetails" xml:space="preserve">
    <value>Corresponde a um caractere FORM FEED (código de caractere 12).</value>
  </data>
  <data name="CheatSheetGroupConditional" xml:space="preserve">
    <value>Condicional de grupo</value>
  </data>
  <data name="CheatSheetGroupConditionalDetails" xml:space="preserve">
    <value>Corresponde condicionalmente a uma de duas opções com base em se o grupo 'indefinido' correspondeu.
Por exemplo, /(z)?(?(1)a|b)/ corresponderá a za porque o primeiro grupo de captura corresponde a z com sucesso, o que faz com que o condicional corresponda à primeira opção a.

O mesmo padrão também corresponderá a b por conta própria, porque o grupo 1 não corresponde, então ele tenta corresponder à segunda opção b.

Você pode referenciar um grupo por nome, número ou posição relativa (por exemplo, -1).</value>
  </data>
  <data name="CheatSheetHexadecimalEscape" xml:space="preserve">
    <value>Escape hexadecimal</value>
  </data>
  <data name="CheatSheetHexadecimalEscapeDetails" xml:space="preserve">
    <value>Caractere com escape hexadecimal no formato \xFF.</value>
  </data>
  <data name="CheatSheetHorizontalWhitespace" xml:space="preserve">
    <value>Espaço em branco horizontal</value>
  </data>
  <data name="CheatSheetHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere de espaço em branco horizontal (espaços, tabulações).</value>
  </data>
  <data name="CheatSheetKeepOut" xml:space="preserve">
    <value>Manter fora</value>
  </data>
  <data name="CheatSheetKeepOutDetails" xml:space="preserve">
    <value>Mantenha o texto correspondido até agora fora da correspondência retornada, essencialmente descartando a correspondência até este ponto. Por exemplo, /o\Kbar/ corresponderá a bar dentro da string foobar</value>
  </data>
  <data name="CheatSheetLazy" xml:space="preserve">
    <value>Preguiçoso</value>
  </data>
  <data name="CheatSheetLazyDetails" xml:space="preserve">
    <value>Torna o quantificador anterior preguiçoso, fazendo com que ele corresponda ao menor número possível de caracteres. Por padrão, os quantificadores são "greedy" e corresponderão ao maior número possível de caracteres.
Esse comportamento é revertido pelo sinalizador/modificador "ungreedy" (U).</value>
  </data>
  <data name="CheatSheetLineBreak" xml:space="preserve">
    <value>Quebra de linha</value>
  </data>
  <data name="CheatSheetLineBreakDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere de quebra de linha, incluindo o par CRLF e CR/LF individualmente.</value>
  </data>
  <data name="CheatSheetLineFeed" xml:space="preserve">
    <value>Alimentação de linha</value>
  </data>
  <data name="CheatSheetLineFeedDetails" xml:space="preserve">
    <value>Corresponde a um caractere LINE FEED (código de caractere 10).</value>
  </data>
  <data name="CheatSheetMatch" xml:space="preserve">
    <value>Correspondência</value>
  </data>
  <data name="CheatSheetMatchAny" xml:space="preserve">
    <value>Corresponder a qualquer</value>
  </data>
  <data name="CheatSheetMatchAnyDetails" xml:space="preserve">
    <value>Um conjunto de caracteres que pode ser usado para corresponder a qualquer caractere, incluindo quebras de linha, sem o sinalizador dotall (s).</value>
  </data>
  <data name="CheatSheetMatchDetails" xml:space="preserve">
    <value>Insere o texto correspondente.
Existem várias sintaxes para este recurso:

$0 \0 \{0}</value>
  </data>
  <data name="CheatSheetModeModifier" xml:space="preserve">
    <value>Modificador de modo</value>
  </data>
  <data name="CheatSheetModeModifierDetails" xml:space="preserve">
    <value>Habilita ou desabilita modos para o restante da expressão. Os modos de correspondência geralmente são mapeados para sinalizadores de expressão. Por exemplo, (?i) habilitará a insensibilidade a maiúsculas e minúsculas para o restante da expressão.
Vários modificadores podem ser especificados e quaisquer modificadores que seguem - são desabilitados. Por exemplo, (?im-s) habilitará os modos de insensibilidade a maiúsculas e minúsculas e multilinha e desabilitará o dotall.

Os modificadores suportados são: i - insensível a maiúsculas e minúsculas, s - dotall, m - multilinha, x - espaçamento livre, J - permite nomes duplicados, U - "ungreedy".</value>
  </data>
  <data name="CheatSheetNamedCapturingGroup" xml:space="preserve">
    <value>Grupo de captura nomeado</value>
  </data>
  <data name="CheatSheetNamedCapturingGroupDetails" xml:space="preserve">
    <value>Cria um grupo de captura que pode ser referenciado por meio do nome especificado.
Existem várias sintaxes para este recurso:

(?'name'ABC) (?P&lt;name&gt;ABC) (?&lt;name&gt;ABC)</value>
  </data>
  <data name="CheatSheetNamedReference" xml:space="preserve">
    <value>Referência nomeada</value>
  </data>
  <data name="CheatSheetNamedReferenceDetails" xml:space="preserve">
    <value>Corresponde aos resultados de um grupo de captura nomeado.
Existem várias sintaxes para este recurso:

\k'name' \k&lt;name&gt; \k{name} \g{name} (?P=name)</value>
  </data>
  <data name="CheatSheetNamedSubroutine" xml:space="preserve">
    <value>Sub-rotina nomeada</value>
  </data>
  <data name="CheatSheetNamedSubroutineDetails" xml:space="preserve">
    <value>Corresponde à expressão em um grupo de captura. Compare isso com uma referência, que corresponde ao resultado.
Existem várias sintaxes para este recurso: \g&lt;name&gt; \g'name' (?&amp;name) (?P&gt;name).</value>
  </data>
  <data name="CheatSheetNegatedCharacterSet" xml:space="preserve">
    <value>Um caractere, exceto A, b ou c</value>
  </data>
  <data name="CheatSheetNegatedCharacterSetDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere que não seja A, b ou c.</value>
  </data>
  <data name="CheatSheetNegativeLookahead" xml:space="preserve">
    <value>Olhar à frente negativo</value>
  </data>
  <data name="CheatSheetNegativeLookaheadDetails" xml:space="preserve">
    <value>Especifica um grupo que não pode corresponder após a expressão principal (se corresponder, o resultado é descartado).</value>
  </data>
  <data name="CheatSheetNegativeLookbehind" xml:space="preserve">
    <value>Olhar para trás negativo</value>
  </data>
  <data name="CheatSheetNegativeLookbehindDetails" xml:space="preserve">
    <value>Especifica um grupo que não pode corresponder antes da expressão principal (se corresponder, o resultado é descartado).</value>
  </data>
  <data name="CheatSheetNonCapturingGroup" xml:space="preserve">
    <value>Grupo sem captura</value>
  </data>
  <data name="CheatSheetNonCapturingGroupDetails" xml:space="preserve">
    <value>Agrupa vários tokens sem criar um grupo de captura.</value>
  </data>
  <data name="CheatSheetNotDigit" xml:space="preserve">
    <value>Não dígito</value>
  </data>
  <data name="CheatSheetNotDigitDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere que não seja um caractere de dígito (0-9). Equivalente a [^0-9].</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespace" xml:space="preserve">
    <value>Não espaço em branco horizontal</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere que não seja um caractere de espaço em branco horizontal (espaços, tabulações).</value>
  </data>
  <data name="CheatSheetNotLineBreak" xml:space="preserve">
    <value>Não quebra de linha</value>
  </data>
  <data name="CheatSheetNotLineBreakDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere que não seja uma quebra de linha. Semelhante a ponto (.), mas não é afetado pelo sinalizador dotall (s).</value>
  </data>
  <data name="CheatSheetNotUnicodeCategory" xml:space="preserve">
    <value>Não categoria unicode</value>
  </data>
  <data name="CheatSheetNotUnicodeCategoryDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere que não esteja na categoria unicode especificada.</value>
  </data>
  <data name="CheatSheetNotUnicodeScript" xml:space="preserve">
    <value>Não script unicode</value>
  </data>
  <data name="CheatSheetNotUnicodeScriptDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere que não esteja no script unicode especificado.</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespace" xml:space="preserve">
    <value>Não espaço em branco vertical</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespaceDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere que não seja um caractere de espaço em branco vertical (quebras de linha).</value>
  </data>
  <data name="CheatSheetNotWhitespace" xml:space="preserve">
    <value>Não espaço em branco</value>
  </data>
  <data name="CheatSheetNotWhitespaceDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere que não seja um caractere de espaço em branco (espaços, tabulações, quebras de linha).</value>
  </data>
  <data name="CheatSheetNotWord" xml:space="preserve">
    <value>Não palavra</value>
  </data>
  <data name="CheatSheetNotWordBoundary" xml:space="preserve">
    <value>Não limite de palavra</value>
  </data>
  <data name="CheatSheetNotWordBoundaryDetails" xml:space="preserve">
    <value>Corresponde a qualquer posição que não seja um limite de palavra. Isso corresponde a uma posição, não a um caractere.</value>
  </data>
  <data name="CheatSheetNotWordDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere que não seja um caractere de palavra (alfanumérico e sublinhado). Equivalente a [^A-Za-z0-9_]</value>
  </data>
  <data name="CheatSheetNull" xml:space="preserve">
    <value>Nulo</value>
  </data>
  <data name="CheatSheetNullDetails" xml:space="preserve">
    <value>Corresponde a um caractere NULL (código de caractere 0).</value>
  </data>
  <data name="CheatSheetNumericReference" xml:space="preserve">
    <value>Referência numérica</value>
  </data>
  <data name="CheatSheetNumericReferenceDetails" xml:space="preserve">
    <value>Corresponde aos resultados de um grupo de captura. Por exemplo, \1 corresponde aos resultados do primeiro grupo de captura e \3 corresponde ao terceiro.
Existem várias sintaxes para este recurso: \1 \g1 \g{1}.

As últimas sintaxes suportam valores relativos precedidos por + ou -. Por exemplo, \g-1 corresponderia ao grupo anterior à referência.</value>
  </data>
  <data name="CheatSheetNumericSubroutine" xml:space="preserve">
    <value>Sub-rotina numéric</value>
  </data>
  <data name="CheatSheetNumericSubroutineDetails" xml:space="preserve">
    <value>Corresponde à expressão em um grupo de captura. Compare isso com uma referência, que corresponde ao resultado. Por exemplo, /(a|b)\g'1'/ pode corresponder a ab, porque a expressão a|b é avaliada novamente.
Existem várias sintaxes para este recurso: \g&lt;1&gt; \g'1' (?1).

Valores relativos precedidos por + ou - também são suportados. Por exemplo, \g&lt;-1&gt; corresponderia ao grupo anterior à referência.</value>
  </data>
  <data name="CheatSheetOctalEscape" xml:space="preserve">
    <value>Escape octal</value>
  </data>
  <data name="CheatSheetOctalEscapeDetails" xml:space="preserve">
    <value>Caractere com escape octal no formato \000. O valor deve ser menor que 255 (\377).
A sintaxe \o{FFF} também é suportada.</value>
  </data>
  <data name="CheatSheetOptional" xml:space="preserve">
    <value>Opcional</value>
  </data>
  <data name="CheatSheetOptionalDetails" xml:space="preserve">
    <value>Corresponde a 0 ou 1 do token anterior, tornando-o efetivamente opcional.</value>
  </data>
  <data name="CheatSheetPlus" xml:space="preserve">
    <value>Mais</value>
  </data>
  <data name="CheatSheetPlusDetails" xml:space="preserve">
    <value>Corresponde a 1 ou mais do token anterior.</value>
  </data>
  <data name="CheatSheetPositiveLookahead" xml:space="preserve">
    <value>Olhar à frente positivo</value>
  </data>
  <data name="CheatSheetPositiveLookaheadDetails" xml:space="preserve">
    <value>Corresponde a um grupo após a expressão principal sem incluí-lo no resultado.</value>
  </data>
  <data name="CheatSheetPositiveLookbehind" xml:space="preserve">
    <value>Olhar para trás positivo</value>
  </data>
  <data name="CheatSheetPositiveLookbehindDetails" xml:space="preserve">
    <value>Corresponde a um grupo antes da expressão principal sem incluí-lo no resultado.</value>
  </data>
  <data name="CheatSheetPossessive" xml:space="preserve">
    <value>Possessivo</value>
  </data>
  <data name="CheatSheetPossessiveDetails" xml:space="preserve">
    <value>Torna o quantificador anterior possessivo. Ele corresponderá a tantos caracteres quanto possível e não os liberará para corresponder aos tokens subsequentes.
Por exemplo, /.*a/ corresponderia a aaa, mas /.*+a/ não corresponderia, porque o ponto de repetição corresponderia e não liberaria o último caractere para corresponder a a.</value>
  </data>
  <data name="CheatSheetPreviousMatchEnd" xml:space="preserve">
    <value>Fim da correspondência anterior</value>
  </data>
  <data name="CheatSheetPreviousMatchEndDetails" xml:space="preserve">
    <value>Corresponde à posição final da correspondência anterior. Isso corresponde a uma posição, não a um caractere.</value>
  </data>
  <data name="CheatSheetQuantifier" xml:space="preserve">
    <value>Quantificador</value>
  </data>
  <data name="CheatSheetQuantifierDetails" xml:space="preserve">
    <value>Corresponde à quantidade especificada do token anterior. {1,3} corresponderá a 1 a 3. {3} corresponderá exatamente a 3. {3,} corresponderá a 3 ou mais.</value>
  </data>
  <data name="CheatSheetRecursion" xml:space="preserve">
    <value>Recursão</value>
  </data>
  <data name="CheatSheetRecursionDetails" xml:space="preserve">
    <value>Tenta corresponder à expressão completa novamente na posição atual.
Por exemplo, /a(?R)?b/ corresponderá a qualquer número de a seguido pelo mesmo número de z: o texto completo de az ou aaaazzzz, mas não azzz.

Existem várias sintaxes para este recurso:

(?R) (?0) \g&lt;0&gt; \g'0'</value>
  </data>
  <data name="CheatSheetReservedCharacters" xml:space="preserve">
    <value>Caracteres reservados</value>
  </data>
  <data name="CheatSheetReservedCharactersDetails" xml:space="preserve">
    <value>Os seguintes caracteres têm significado especial e devem ser precedidos por \ (barra invertida) para representar um caractere literal:
+*?^$\.[]{}()|/

Dentro de um conjunto de caracteres, apenas \, - e ] precisam de escape.</value>
  </data>
  <data name="CheatSheetStar" xml:space="preserve">
    <value>Estrela</value>
  </data>
  <data name="CheatSheetStarDetails" xml:space="preserve">
    <value>Corresponde a 0 ou mais do token anterior.</value>
  </data>
  <data name="CheatSheetStrictEndOfString" xml:space="preserve">
    <value>Fim estrito da string</value>
  </data>
  <data name="CheatSheetStrictEndOfStringDetails" xml:space="preserve">
    <value>Corresponde ao final da string. Ao contrário de $ ou \Z, ele não permite uma nova linha à direita. Isso não é afetado pelo sinalizador de várias linhas (m). Isso corresponde a uma posição, não a um caractere.</value>
  </data>
  <data name="CheatSheetSyntax" xml:space="preserve">
    <value>Sintaxe</value>
  </data>
  <data name="CheatSheetTab" xml:space="preserve">
    <value>Tabulação</value>
  </data>
  <data name="CheatSheetTabDetails" xml:space="preserve">
    <value>Corresponde a um caractere TAB (código de caractere 9).</value>
  </data>
  <data name="CheatSheetTitle" xml:space="preserve">
    <value>Folha de dicas</value>
  </data>
  <data name="CheatSheetUnicodeCategory" xml:space="preserve">
    <value>Categoria Unicode</value>
  </data>
  <data name="CheatSheetUnicodeCategoryDetails" xml:space="preserve">
    <value>Corresponde a um caractere na categoria unicode especificada. Por exemplo, \p{Ll} corresponderá a qualquer letra minúscula.</value>
  </data>
  <data name="CheatSheetUnicodeEscape" xml:space="preserve">
    <value>Escape Unicode</value>
  </data>
  <data name="CheatSheetUnicodeEscapeDetails" xml:space="preserve">
    <value>Caractere com escape Unicode no formato \x{FF}.</value>
  </data>
  <data name="CheatSheetUnicodeGrapheme" xml:space="preserve">
    <value>Grafema Unicode</value>
  </data>
  <data name="CheatSheetUnicodeGraphemeDetails" xml:space="preserve">
    <value>Corresponde a qualquer grafema unicode único (ou seja, caractere). Isso inclui quebras de linha (independentemente do modo dotall) e grafemas codificados como vários pontos de código.</value>
  </data>
  <data name="CheatSheetUnicodeScript" xml:space="preserve">
    <value>Script Unicode</value>
  </data>
  <data name="CheatSheetUnicodeScriptDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere no script unicode especificado. Por exemplo, \p{Arabic} corresponderá a caracteres no script árabe.</value>
  </data>
  <data name="CheatSheetVerticalWhitespace" xml:space="preserve">
    <value>Espaço em branco vertical</value>
  </data>
  <data name="CheatSheetVerticalWhitespaceDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere de espaço em branco vertical (quebras de linha).</value>
  </data>
  <data name="CheatSheetWhitespace" xml:space="preserve">
    <value>Espaço em branco</value>
  </data>
  <data name="CheatSheetWhitespaceDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere de espaço em branco (espaços, tabulações, quebras de linha).</value>
  </data>
  <data name="CheatSheetWord" xml:space="preserve">
    <value>Palavra</value>
  </data>
  <data name="CheatSheetWordBoundary" xml:space="preserve">
    <value>Limite de palavra</value>
  </data>
  <data name="CheatSheetWordBoundaryDetails" xml:space="preserve">
    <value>Corresponde a uma posição de limite de palavra entre um caractere de palavra e um caractere ou posição que não seja de palavra (início/fim da string). Consulte a classe de caracteres de palavra (w) para obter mais informações.</value>
  </data>
  <data name="CheatSheetWordDetails" xml:space="preserve">
    <value>Corresponde a qualquer caractere de palavra (alfanumérico e sublinhado). Corresponde apenas a caracteres ASCII baixos (sem caracteres acentuados ou não romanos). Equivalente a [A-Za-z0-9_]</value>
  </data>
  <data name="Configuration" xml:space="preserve">
    <value>Configuração</value>
  </data>
  <data name="CultureInvariant" xml:space="preserve">
    <value>Cultura Invariante</value>
  </data>
  <data name="CultureInvariantDescription" xml:space="preserve">
    <value>Especifica que as diferenças culturais na linguagem são ignoradas.</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Validar e testar expressões regulares</value>
  </data>
  <data name="EcmaScript" xml:space="preserve">
    <value>ECMA Script</value>
  </data>
  <data name="EcmaScriptDescription" xml:space="preserve">
    <value>Habilita o comportamento compatível com ECMAScript para a expressão. Este valor pode ser usado apenas em conjunto com as opções Cultura Invariante, Ignorar Maiúsculas/Minúsculas e Multilinha.</value>
  </data>
  <data name="IgnoreCase" xml:space="preserve">
    <value>Ignorar Maiúsculas/Minúsculas</value>
  </data>
  <data name="IgnoreCaseDescription" xml:space="preserve">
    <value>Especifica correspondência que não diferencia maiúsculas de minúsculas.</value>
  </data>
  <data name="IgnoreWhitespace" xml:space="preserve">
    <value>Ignorar Espaço em Branco</value>
  </data>
  <data name="IgnoreWhitespaceDescription" xml:space="preserve">
    <value>Elimina espaços em branco sem escape do padrão e habilita comentários marcados com #. No entanto, este valor não afeta ou elimina espaços em branco em classes de caracteres, quantificadores numéricos ou tokens que marcam o início de elementos de linguagem de expressão regular individuais.</value>
  </data>
  <data name="LongDisplayTitle" xml:space="preserve">
    <value>Testador de Expressão Regular</value>
  </data>
  <data name="MatchGroupPrefix" xml:space="preserve">
    <value>Grupo</value>
  </data>
  <data name="MatchInformation" xml:space="preserve">
    <value>Informações de correspondência</value>
  </data>
  <data name="MatchLocation" xml:space="preserve">
    <value>Localização</value>
  </data>
  <data name="MatchName" xml:space="preserve">
    <value>Nome</value>
  </data>
  <data name="MatchNamePrefix" xml:space="preserve">
    <value>Correspondência</value>
  </data>
  <data name="MatchValue" xml:space="preserve">
    <value>Valor</value>
  </data>
  <data name="Multiline" xml:space="preserve">
    <value>Multilinha</value>
  </data>
  <data name="MultilineDescription" xml:space="preserve">
    <value>Altera o significado de ^ e $ para que eles correspondam ao início e ao fim, respectivamente, de qualquer linha, e não apenas ao início e ao fim de toda a string.</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>Opções</value>
  </data>
  <data name="RegularExpression" xml:space="preserve">
    <value>Expressão regular</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>Da direita para a esquerda</value>
  </data>
  <data name="RightToLeftDescription" xml:space="preserve">
    <value>Especifica que a pesquisa será da direita para a esquerda em vez de da esquerda para a direita.</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value>expressão regular</value>
  </data>
  <data name="ShortDisplayTitle" xml:space="preserve">
    <value>RegEx</value>
  </data>
  <data name="Singleline" xml:space="preserve">
    <value>Linha única</value>
  </data>
  <data name="SinglelineDescription" xml:space="preserve">
    <value>Altera o significado do ponto (.) para que ele corresponda a todos os caracteres (em vez de todos os caracteres, exceto \n).</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>Texto</value>
  </data>
</root>