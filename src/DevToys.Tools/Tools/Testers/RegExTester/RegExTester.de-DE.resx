<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessibleName" xml:space="preserve">
    <value>Prüfwerkzeug für reguläre Ausdrücke</value>
  </data>
  <data name="AllMatches" xml:space="preserve">
    <value>Alle Übereinstimmungen</value>
  </data>
  <data name="AllMatchesDescription" xml:space="preserve">
    <value>Suche nach allen Übereinstimmungen im Text oder Stopp nach der ersten Übereinstimmung.</value>
  </data>
  <data name="CheatSheetAlternation" xml:space="preserve">
    <value>Abwechslung</value>
  </data>
  <data name="CheatSheetAlternationDetails" xml:space="preserve">
    <value>Verhält sich wie ein boolesches ODER. Stimmt mit dem Ausdruck vor oder nach dem | überein.
Es kann innerhalb einer Gruppe oder für einen gesamten Ausdruck ausgeführt werden. Die Muster werden der Reihe nach getestet.</value>
  </data>
  <data name="CheatSheetAnyCharacter" xml:space="preserve">
    <value>Jedes/Beliebiges Zeichen außer Zeilenumbruch [Überarbeitung Jedes/Beliebiges]</value>
  </data>
  <data name="CheatSheetAnyCharacterDetails" xml:space="preserve">
    <value>Stimmt mit jedem Zeichen außer Zeilenumbruch überein. Äquivalent zu [^\n\r].</value>
  </data>
  <data name="CheatSheetAtomicGroup" xml:space="preserve">
    <value>Atomare Gruppe</value>
  </data>
  <data name="CheatSheetAtomicGroupDetails" xml:space="preserve">
    <value>Nicht-erfassende Gruppe, die nach dem Matching rückwärtslaufende Positionen verwirft.
Beispielweise wird /(?&gt;ab|a)b/ mit abb übereinstimmen, aber nicht mit ab, weil die atomare Gruppe verhindert, dass nach einem Treffer mit der Option ab ein erneuter Versuch mit der Option a unternommen wird.</value>
  </data>
  <data name="CheatSheetBeginning" xml:space="preserve">
    <value>Anfang</value>
  </data>
  <data name="CheatSheetBeginningDetails" xml:space="preserve">
    <value>Stimmt mit dem Anfang der Zeichenkette oder dem Anfang einer Zeile überein, wenn das Mehrzeilig-Kennzeichen (m) aktiviert ist. Dies stimmt mit einer Position überein, nicht einem Zeichen.</value>
  </data>
  <data name="CheatSheetBeginningOfString" xml:space="preserve">
    <value>Anfang der Zeichenkette</value>
  </data>
  <data name="CheatSheetBeginningOfStringDetails" xml:space="preserve">
    <value>Stimmt mit dem Anfang der Zeichenkette überein. Im Gegensatz zu ^ wird dies nicht durch das Mehrzeilig-Kennzeichen (m) beeinflusst. Dies stimmt mit einer Position überein, nicht einem Zeichen.</value>
  </data>
  <data name="CheatSheetBell" xml:space="preserve">
    <value>Glocke</value>
  </data>
  <data name="CheatSheetBellDetails" xml:space="preserve">
    <value>Stimmt mit einem BELL-Zeichen überein (Zeichencode 7).</value>
  </data>
  <data name="CheatSheetBranchResetGroup" xml:space="preserve">
    <value>Zweig-Zurücksetzgruppe</value>
  </data>
  <data name="CheatSheetBranchResetGroupDetails" xml:space="preserve">
    <value>Alternative Gruppen definieren, die dieselben Gruppennummern haben.
Beispielsweise würden in (?|(a)|(b)) beide Gruppen (a und b) als Gruppe Nr. 1 gezählt.</value>
  </data>
  <data name="CheatSheetCaptureGroup" xml:space="preserve">
    <value>Erfassungsgruppe [evtl. Überarbeitung]</value>
  </data>
  <data name="CheatSheetCaptureGroupDetails" xml:space="preserve">
    <value>Fügt die Ergebnisse der angegebenen Erfassungsgruppe ein. Zum Beispiel würde $3 die dritte Erfassungsgruppe einfügen..
Für diese Funktion gibt es mehrere Syntaxen:

$1 \1 \{1}</value>
  </data>
  <data name="CheatSheetCapturingGroup" xml:space="preserve">
    <value>Erfassungsgruppe</value>
  </data>
  <data name="CheatSheetCapturingGroupDetails" xml:space="preserve">
    <value>Fasst mehrere Token zusammen und erstellt eine Erfassungsgruppe zum Extrahieren einer Teilzeichenkette oder zur Verwendung eines Rückverweises.</value>
  </data>
  <data name="CheatSheetCarriageReturn" xml:space="preserve">
    <value>Wagenrücklauf</value>
  </data>
  <data name="CheatSheetCarriageReturnDetails" xml:space="preserve">
    <value>Stimmt mit einem WAGENRÜCKLAUF-Zeichen überein (Zeichencode 13).</value>
  </data>
  <data name="CheatSheetCategoryAnchors" xml:space="preserve">
    <value>Anker</value>
  </data>
  <data name="CheatSheetCategoryCharacterClasses" xml:space="preserve">
    <value>Charakterklassen</value>
  </data>
  <data name="CheatSheetCategoryEscapedCharacters" xml:space="preserve">
    <value>Maskierungszeichen</value>
  </data>
  <data name="CheatSheetCategoryGroupsReferences" xml:space="preserve">
    <value>Gruppen und Referenzen</value>
  </data>
  <data name="CheatSheetCategoryLookaround" xml:space="preserve">
    <value>Umschauen</value>
  </data>
  <data name="CheatSheetCategoryQuantifiersAlternation" xml:space="preserve">
    <value>Quantoren und Abwechslung</value>
  </data>
  <data name="CheatSheetCategorySpecial" xml:space="preserve">
    <value>Besonderes</value>
  </data>
  <data name="CheatSheetCategorySubstitution" xml:space="preserve">
    <value>Auswechslung</value>
  </data>
  <data name="CheatSheetCharacterRange" xml:space="preserve">
    <value>Zeichenbereich</value>
  </data>
  <data name="CheatSheetCharacterRangeDetails" xml:space="preserve">
    <value>Stimmt mit einem Zeichen überein, dessen Zeichencode zwischen den beiden angegebenen Zeichen einschließlich liegt.</value>
  </data>
  <data name="CheatSheetCharacterSet" xml:space="preserve">
    <value>Ein einzelnes Zeichen aus A, b oder c</value>
  </data>
  <data name="CheatSheetCharacterSetDetails" xml:space="preserve">
    <value>Stimmt entweder einem A, b oder c Zeichen überein</value>
  </data>
  <data name="CheatSheetComment" xml:space="preserve">
    <value>Kommentar</value>
  </data>
  <data name="CheatSheetCommentDetails" xml:space="preserve">
    <value>Ermöglicht es dir, einen Kommentar in deinem Ausdruck einzufügen, der bei der Suche nach einer Übereinstimmung ignoriert wird.</value>
  </data>
  <data name="CheatSheetConditional" xml:space="preserve">
    <value>Bedingt</value>
  </data>
  <data name="CheatSheetConditionalDetails" xml:space="preserve">
    <value>Stimmt bedingt mit einer von zwei Optionen überein, je nachdem, ob eine Umschau übereinstimmt.
Zum Beispiel wird /(?(?=a)ab|..)/ mit ab und zx übereinstimmen, aber nicht mit ax, denn wenn das erste Zeichen der Bedingung a übereinstimmt, wird das Muster ab ausgewertet.

Als Bedingung kann eine beliebige Umschau verwendet werden. Bei einer Vorausschau beginnt die nachfolgende Übereinstimmung mit dem Beginn der Bedingung, bei einer Nachschau beginnt sie danach.</value>
  </data>
  <data name="CheatSheetControlCharacterEscape" xml:space="preserve">
    <value>Maskierungssteuerzeichen</value>
  </data>
  <data name="CheatSheetControlCharacterEscapeDetails" xml:space="preserve">
    <value>Maskierungssteuerzeichen in der Form \cZ. Dies kann von \cA (SOH, Zeichencode 1) bis \cZ (SUB, Zeichencode 26) reichen..</value>
  </data>
  <data name="CheatSheetDefine" xml:space="preserve">
    <value>Definieren</value>
  </data>
  <data name="CheatSheetDefineDetails" xml:space="preserve">
    <value>Wird verwendet, um benannte Gruppen zur Verwendung als Unterprogramme zu definieren, ohne sie in die Übereinstimmung einzubeziehen.
Zum Beispiel wird /A(?(DEFINE)(?'foo'Z))B\g'foo'/ mit ABZ übereinstimmen, da die definieren-Gruppe bei der Übereinstimmung ignoriert wird, außer um das Unterprogramm foo zu definieren, auf das später mit \g'foo' verwiesen wird.</value>
  </data>
  <data name="CheatSheetDescription" xml:space="preserve">
    <value>Beschreibung</value>
  </data>
  <data name="CheatSheetDigit" xml:space="preserve">
    <value>Ziffer</value>
  </data>
  <data name="CheatSheetDigitDetails" xml:space="preserve">
    <value>Stimmt mit einer beliebigen Ziffernzeichen (0-9) überein. Äquivalent zu [0-9].</value>
  </data>
  <data name="CheatSheetEnd" xml:space="preserve">
    <value>Ende</value>
  </data>
  <data name="CheatSheetEndDetails" xml:space="preserve">
    <value>Stimmt mit dem Ende der Zeichenkette oder dem Ende einer Zeile überein, wenn das Mehrzeilig-Kennzeichen (m) aktiviert ist. Dies stimmt mit einer Position überein, nicht einem Zeichen.</value>
  </data>
  <data name="CheatSheetEndOfString" xml:space="preserve">
    <value>Ende der Zeichenkette</value>
  </data>
  <data name="CheatSheetEndOfStringDetails" xml:space="preserve">
    <value>Stimmt mit dem Ende der Zeichenkette überein. Im Gegensatz zu $ wird dies nicht durch das Mehrzeilig-Kennzeichen (m) beeinflusst. Dies stimmt mit einer Position überein, nicht einem Zeichen.</value>
  </data>
  <data name="CheatSheetEsc" xml:space="preserve">
    <value>Esc</value>
  </data>
  <data name="CheatSheetEscapedCharacters" xml:space="preserve">
    <value>Maskierungszeichen</value>
  </data>
  <data name="CheatSheetEscapedCharactersDetails" xml:space="preserve">
    <value>Der Einfachheit halber werden die folgenden Zeichen in der Ersetzungszeichenkette in RegExr unterstützt: \n, \r, \t, \\\, und Unicode-Maskierungszeichen \uFFFF. Dies kann in Ihrer Einsatzumgebung variieren.</value>
  </data>
  <data name="CheatSheetEscapeSequence" xml:space="preserve">
    <value>Escape-Sequenz</value>
  </data>
  <data name="CheatSheetEscapeSequenceDetails" xml:space="preserve">
    <value>Alle Zeichen zwischen \Q und \E werden als Literalzeichenkette interpretiert. Wenn \E weggelassen wird, wird bis zum Ende des Ausdrucks fortgefahren. Beispielsweise stimmt der Ausdruck /\Q(?.)\E/ mit der Zeichenkette (?.) überein.</value>
  </data>
  <data name="CheatSheetEscDetails" xml:space="preserve">
    <value>Stimmt mit einem ESC-Zeichen überein (Zeichencode 27).</value>
  </data>
  <data name="CheatSheetFormFeed" xml:space="preserve">
    <value>Formularvorschub</value>
  </data>
  <data name="CheatSheetFormFeedDetails" xml:space="preserve">
    <value>Stimmt mit einem FORMULARVORSCHUB-Zeichen überein(Zeichencode 12).</value>
  </data>
  <data name="CheatSheetGroupConditional" xml:space="preserve">
    <value>Gruppenbedingt</value>
  </data>
  <data name="CheatSheetGroupConditionalDetails" xml:space="preserve">
    <value>Stimmt bedingt mit einer von zwei Optionen überein, basierend darauf, ob die Gruppe 'undefiniert' übereinstimmt.
Beispielsweise wird /(z)?(?(1)a|b)/ mit za übereinstimmen, weil die erste Erfassungsgruppe erfolgreich mit z übereinstimmt, was dazu führt, dass die Bedingung mit der ersten Option a übereinstimmt.

Dasselbe Muster wird auch b allein übereinstimmen, weil Gruppe 1 nicht übereinstimmt und stattdessen versucht wird, der zweiten Option b zu übereinstimmen.

Du kannst eine Gruppe nach Name, Nummer oder relativer Position referenzieren (ex. -1).</value>
  </data>
  <data name="CheatSheetHexadecimalEscape" xml:space="preserve">
    <value>Hexadezimales Maskierungszeichen</value>
  </data>
  <data name="CheatSheetHexadecimalEscapeDetails" xml:space="preserve">
    <value>Hexadezimales Maskierungszeichen im Format \xFF.</value>
  </data>
  <data name="CheatSheetHorizontalWhitespace" xml:space="preserve">
    <value>Horizontaler Leerraum</value>
  </data>
  <data name="CheatSheetHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Stimmt mit jedem horizontalen Leerraum überein (Leerzeichen, Tabulatoren).</value>
  </data>
  <data name="CheatSheetKeepOut" xml:space="preserve">
    <value>Weglassen (evtl. Überarbeitung)</value>
  </data>
  <data name="CheatSheetKeepOutDetails" xml:space="preserve">
    <value>Bisher übereinstimmenden Text aus der zurückgegebenen Übereinstimmung heraushalten und die Übereinstimmung bis zu diesem Punkt im Wesentlichen verwerfen. Beispielsweise stimmt /o\Kbar/ mit bar innerhalb der Zeichenkette foobar überein (evtl. Überarbeitung!)</value>
  </data>
  <data name="CheatSheetLazy" xml:space="preserve">
    <value>Faul</value>
  </data>
  <data name="CheatSheetLazyDetails" xml:space="preserve">
    <value>Macht den vorhergehenden Quantor faul, sodass er mit so wenigen Zeichen wie möglich übereinstimmt. Standardmäßig sind Quantoren gierig und stimmen mit so vielen Zeichen wie möglich überein.
Dieses Verhalten wird durch das Ungreedy (U)-Kennzeichen/-Modifikator umgekehrt.</value>
  </data>
  <data name="CheatSheetLineBreak" xml:space="preserve">
    <value>Zeilenumbruch</value>
  </data>
  <data name="CheatSheetLineBreakDetails" xml:space="preserve">
    <value>Stimmt mit jedem Zeilenumbruchzeichen überein, einschließlich des CRLF-Paars, und CR/LF einzeln.</value>
  </data>
  <data name="CheatSheetLineFeed" xml:space="preserve">
    <value>Zeilenvorschub</value>
  </data>
  <data name="CheatSheetLineFeedDetails" xml:space="preserve">
    <value>Stimmt mit einem ZEILENVORSCHUB-Zeichen überein (Zeichencode 10).</value>
  </data>
  <data name="CheatSheetMatch" xml:space="preserve">
    <value>Übereinstimmung</value>
  </data>
  <data name="CheatSheetMatchAny" xml:space="preserve">
    <value>Beliebiges Übereinstimmen (evtl. Überarbeitung)</value>
  </data>
  <data name="CheatSheetMatchAnyDetails" xml:space="preserve">
    <value>Ein Zeichensatz, der verwendet werden kann, um jedes beliebige Zeichen, einschließlich Zeilenumbrüchen, ohne das Allepunkten-Kennzeichen (s) übereinzustimmen.</value>
  </data>
  <data name="CheatSheetMatchDetails" xml:space="preserve">
    <value>Fügt den übereinstimmenden Text ein.
Für diese Funktion gibt es mehrere Syntaxen:

$0 \0 \{0}</value>
  </data>
  <data name="CheatSheetModeModifier" xml:space="preserve">
    <value>Modus-Modifikator</value>
  </data>
  <data name="CheatSheetModeModifierDetails" xml:space="preserve">
    <value>Aktiviert oder deaktiviert Modi für den Rest des Ausdrucks. Übereinstimmungs-Modi werden im Allgemeinen Ausdrucks-Kennzeichen zugeordnet. Beispielsweise würde (?i) die Groß-/Kleinschreibung für den Rest des Ausdrucks aktivieren.
Es können mehrere Modifikatoren angegeben werden, und alle Modifikatoren die folgen - sind deaktiviert. Beispielsweise würde (?im-s) die Groß- und Kleinschreibung aktivieren &amp; mehrzeilige Modi, und allepunkten deaktivieren.

Unterstützte Modifikatoren sind: i - Groß-/Kleinschreibung nicht beachten, s - allepunkten, m - mehrzeilig, x - freier Abstand, J - doppelte Namen zulassen, U - genügsam.</value>
  </data>
  <data name="CheatSheetNamedCapturingGroup" xml:space="preserve">
    <value>Benannte Erfassungsgruppe</value>
  </data>
  <data name="CheatSheetNamedCapturingGroupDetails" xml:space="preserve">
    <value>Erstellt eine Erfassungsgruppe, die über den angegebenen Namen referenziert werden kann.
Für diese Funktion gibt es mehrere Syntaxen:

(?'name'ABC) (?P&lt;name&gt;ABC) (?&lt;name&gt;ABC)</value>
  </data>
  <data name="CheatSheetNamedReference" xml:space="preserve">
    <value>Benannte Referenz</value>
  </data>
  <data name="CheatSheetNamedReferenceDetails" xml:space="preserve">
    <value>Stimmt mit den Ergebnissen einer benannten Erfassungsgruppe überein.
Für diese Funktion gibt es mehrere Syntaxen:

\k'name' \k&lt;name&gt; \k{name} \g{name} (?P=name)</value>
  </data>
  <data name="CheatSheetNamedSubroutine" xml:space="preserve">
    <value>Benanntes Unterprogramm</value>
  </data>
  <data name="CheatSheetNamedSubroutineDetails" xml:space="preserve">
    <value>Entspricht dem Ausdruck in einer Erfassungsgruppe. Vergleiche dies mit einer Referenz, die mit dem Ergebnis übereinstimmt.
Für diese Funktion gibt es mehrere Syntaxen: \g&lt;name&gt; \g'name' (?&amp;name) (?P&gt;name).</value>
  </data>
  <data name="CheatSheetNegatedCharacterSet" xml:space="preserve">
    <value>Ein Zeichen außer A, b oder c</value>
  </data>
  <data name="CheatSheetNegatedCharacterSetDetails" xml:space="preserve">
    <value>Mit jedem Zeichen übereinstimmen, das nicht A, b oder c ist.</value>
  </data>
  <data name="CheatSheetNegativeLookahead" xml:space="preserve">
    <value>Negative Vorausschau</value>
  </data>
  <data name="CheatSheetNegativeLookaheadDetails" xml:space="preserve">
    <value>Gibt eine Gruppe an, die nach dem Hauptausdruck nicht übereinstimmen darf (wenn sie übereinstimmt, wird das Ergebnis verworfen).</value>
  </data>
  <data name="CheatSheetNegativeLookbehind" xml:space="preserve">
    <value>Negativer Rückblick</value>
  </data>
  <data name="CheatSheetNegativeLookbehindDetails" xml:space="preserve">
    <value>Gibt eine Gruppe an, die nicht vor dem Hauptausdruck übereinstimmen darf (wenn sie übereinstimmt, wird das Ergebnis verworfen).</value>
  </data>
  <data name="CheatSheetNonCapturingGroup" xml:space="preserve">
    <value>Nicht-erfassende Gruppe</value>
  </data>
  <data name="CheatSheetNonCapturingGroupDetails" xml:space="preserve">
    <value>Fasst mehrere Token zusammen, ohne eine Erfassungsgruppe zu erstellen.</value>
  </data>
  <data name="CheatSheetNotDigit" xml:space="preserve">
    <value>Keine Ziffer</value>
  </data>
  <data name="CheatSheetNotDigitDetails" xml:space="preserve">
    <value>Stimmt mit jedem Zeichen überein, das kein Ziffernzeichen (0-9) ist. Äquivalent zu [^0-9].</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespace" xml:space="preserve">
    <value>Nicht horizontales Leerzeichen</value>
  </data>
  <data name="CheatSheetNotHorizontalWhitespaceDetails" xml:space="preserve">
    <value>Stimmt mit jedem Zeichen überein, das kein horizontaler Leerraum ist (Leerzeichen, Tabulatoren).</value>
  </data>
  <data name="CheatSheetNotLineBreak" xml:space="preserve">
    <value>Nicht Zeilenumbruch</value>
  </data>
  <data name="CheatSheetNotLineBreakDetails" xml:space="preserve">
    <value>Stimmt mit jedem Zeichen überein, das kein Zeilenumbruch ist. Ähnlich wie Punkt (.), wird aber nicht durch das Allepunkten-Kennzeichen (s) beeinträchtigt.</value>
  </data>
  <data name="CheatSheetNotUnicodeCategory" xml:space="preserve">
    <value>Nicht Unicode-Kategorie</value>
  </data>
  <data name="CheatSheetNotUnicodeCategoryDetails" xml:space="preserve">
    <value>Stimmt mit jedem Zeichen überein, das nicht in der angegebenen Unicode-Kategorie enthalten ist.</value>
  </data>
  <data name="CheatSheetNotUnicodeScript" xml:space="preserve">
    <value>Nicht Unicode-Skript</value>
  </data>
  <data name="CheatSheetNotUnicodeScriptDetails" xml:space="preserve">
    <value>Stimmt mit jedem Zeichen überein, das nicht im angegebenen Unicode-Skript enthalten ist.</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespace" xml:space="preserve">
    <value>Nicht vertikaler Leerraum</value>
  </data>
  <data name="CheatSheetNotVerticalWhitespaceDetails" xml:space="preserve">
    <value>Stimmt mit jedem Zeichen überein, das kein vertikaler Leerraum ist (Zeilenumbruch).</value>
  </data>
  <data name="CheatSheetNotWhitespace" xml:space="preserve">
    <value>Nicht Leerzeichen</value>
  </data>
  <data name="CheatSheetNotWhitespaceDetails" xml:space="preserve">
    <value>Stimmt mit jedem Zeichen überein, das kein Leerraum ist (Leerzeichen, Tabulatoren, Zeilenumbrüche).</value>
  </data>
  <data name="CheatSheetNotWord" xml:space="preserve">
    <value>Nicht Wort</value>
  </data>
  <data name="CheatSheetNotWordBoundary" xml:space="preserve">
    <value>Nicht Wortgrenze</value>
  </data>
  <data name="CheatSheetNotWordBoundaryDetails" xml:space="preserve">
    <value>Stimmt mit jeder Position überein, die keine Wortgrenze ist. Dies entspricht einer Position, nicht einem Zeichen.</value>
  </data>
  <data name="CheatSheetNotWordDetails" xml:space="preserve">
    <value>Stimmt mit jedem Zeichen überein, das kein Wortzeichen ist (alphanumerisch &amp; Unterstrich). Äquivalent zu [^A-Za-z0-9_]</value>
  </data>
  <data name="CheatSheetNull" xml:space="preserve">
    <value>Null</value>
  </data>
  <data name="CheatSheetNullDetails" xml:space="preserve">
    <value>Entspricht einem NULL-Zeichen (Zeichencode 0).</value>
  </data>
  <data name="CheatSheetNumericReference" xml:space="preserve">
    <value>Numerische Referenz</value>
  </data>
  <data name="CheatSheetNumericReferenceDetails" xml:space="preserve">
    <value>Stimmt mit Ergebnissen einer Erfassungsgruppe überein. Beispielsweise entspricht \1 den Ergebnissen der ersten Erfassungsgruppe &amp; \3 entspricht der dritten.
Für diese Funktion gibt es mehrere Syntaxen: \1 \g1 \g{1}.

Die letztgenannten Syntaxen unterstützen relative Werte, denen ein + oder - vorangestellt ist. Beispielsweise würde \g-1 mit der Gruppe vor der Referenz übereinstimmen.</value>
  </data>
  <data name="CheatSheetNumericSubroutine" xml:space="preserve">
    <value>Numerisches Unterprogramm</value>
  </data>
  <data name="CheatSheetNumericSubroutineDetails" xml:space="preserve">
    <value>Stimmt mit dem Ausdruck in einer Erfassungsgruppe überein. Vergleiche dies mit einer Referenz, die mit dem Ergebnis übereinstimmt. Beispielsweise kann /(a|b)\g'1'/ mit ab übereinstimmen, da der Ausdruck a|b erneut ausgewertet wird.
Für diese Funktion gibt es mehrere Syntaxen: \g&lt;1&gt; \g'1' (?1).

Relative Werte mit vorangestelltem + oder - werden ebenfalls unterstützt. Zum Beispiel würde \g&lt;-1&gt; mit der Gruppe übereinstimmen, die dem Verweis vorausgeht.</value>
  </data>
  <data name="CheatSheetOctalEscape" xml:space="preserve">
    <value>Oktales Maskierungszeichen</value>
  </data>
  <data name="CheatSheetOctalEscapeDetails" xml:space="preserve">
    <value>Oktales Maskierungszeichen in der Form \000. Der Wert muss kleiner als 255 (\377) sein..
Die Syntax \o{FFF} wird ebenfalls unterstützt.</value>
  </data>
  <data name="CheatSheetOptional" xml:space="preserve">
    <value>Optional</value>
  </data>
  <data name="CheatSheetOptionalDetails" xml:space="preserve">
    <value>Stimmt mit 0 oder 1 des vorhergehenden Tokens überein und ist somit optional.</value>
  </data>
  <data name="CheatSheetPlus" xml:space="preserve">
    <value>Plus</value>
  </data>
  <data name="CheatSheetPlusDetails" xml:space="preserve">
    <value>Stimmt mit 1 oder mehreren der vorhergehenden Token überein.</value>
  </data>
  <data name="CheatSheetPositiveLookahead" xml:space="preserve">
    <value>Positive Vorausschau</value>
  </data>
  <data name="CheatSheetPositiveLookaheadDetails" xml:space="preserve">
    <value>Stimmt mit einer Gruppe nach dem Hauptausdruck überein, ohne sie in das Ergebnis einzubeziehen.</value>
  </data>
  <data name="CheatSheetPositiveLookbehind" xml:space="preserve">
    <value>Positiver Rückblick</value>
  </data>
  <data name="CheatSheetPositiveLookbehindDetails" xml:space="preserve">
    <value>Stimmt mit einer Gruppe vor dem Hauptausdruck überein, ohne sie in das Ergebnis einzubeziehen.</value>
  </data>
  <data name="CheatSheetPossessive" xml:space="preserve">
    <value>Possessiv</value>
  </data>
  <data name="CheatSheetPossessiveDetails" xml:space="preserve">
    <value>Macht den vorhergehenden Quantor besitzergreifend. Es werden so viele Zeichen wie möglich abgeglichen und nicht freigegeben, um mit nachfolgenden Token übereinzustimmen.
Zum Beispiel würde /.*a/ mit aaa übereinstimmen, aber /.*+a/ nicht, weil der sich wiederholende Punkt übereinstimmt und das letzte Zeichen nicht freigibt, um a zu entsprechen.</value>
  </data>
  <data name="CheatSheetPreviousMatchEnd" xml:space="preserve">
    <value>Vorherhiges Übereinstimmungsende (evtl. Überarbeitung)</value>
  </data>
  <data name="CheatSheetPreviousMatchEndDetails" xml:space="preserve">
    <value>Entspricht der Endposition der vorherigen Übereinstimmung. Dies entspricht einer Position, nicht einem Zeichen.</value>
  </data>
  <data name="CheatSheetQuantifier" xml:space="preserve">
    <value>Quantor</value>
  </data>
  <data name="CheatSheetQuantifierDetails" xml:space="preserve">
    <value>Stimmt mit der angegebenen Menge des vorherigen Tokens überein. {1,3} entspricht 1 bis 3. {3} entspricht genau 3. {3,} entspricht 3 oder mehr.</value>
  </data>
  <data name="CheatSheetRecursion" xml:space="preserve">
    <value>Rekursion</value>
  </data>
  <data name="CheatSheetRecursionDetails" xml:space="preserve">
    <value>Versucht, den vollständigen Ausdruck erneut an der aktuellen Position abzugleichen.
Zum Beispiel passt /a(?R)?b/ auf jede Anzahl von a, gefolgt von der gleichen Anzahl von z: der vollständige Text von az oder aaaazzzz, aber nicht azzz. (evtl. Überarbeitung)

Für diese Funktion gibt es mehrere Syntaxen:

(?R) (?0) \g&lt;0&gt; \g'0'</value>
  </data>
  <data name="CheatSheetReservedCharacters" xml:space="preserve">
    <value>Reservierte Zeichen</value>
  </data>
  <data name="CheatSheetReservedCharactersDetails" xml:space="preserve">
    <value>Die folgenden Zeichen haben eine besondere Bedeutung und sollten mit einem \ (Rückstrich) vorangestellt werden, um ein Literalzeichen darzustellen: (evtl. Überarbeitung (Literalzeichen oder Zeichenliteral))
+*?^$\.[]{}()|/

Innerhalb eines Zeichensatzes müssen nur \, - und ] maskiert werden.</value>
  </data>
  <data name="CheatSheetStar" xml:space="preserve">
    <value>Stern</value>
  </data>
  <data name="CheatSheetStarDetails" xml:space="preserve">
    <value>Stimmt mit 0 oder mehr des vorhergehenden Tokens überein.</value>
  </data>
  <data name="CheatSheetStrictEndOfString" xml:space="preserve">
    <value>Striktes Ende der Zeichenkette</value>
  </data>
  <data name="CheatSheetStrictEndOfStringDetails" xml:space="preserve">
    <value>Stimmt mit dem Ende der Zeichenkette überein. Im Gegensatz zu $ oder \Z ist ein nachfolgender Zeilenumbruch nicht möglich. Dies wird durch das Mehrzeilig-Kennzeichen (m) nicht beeinflusst. Dies entspricht einer Position, nicht einem Zeichen.</value>
  </data>
  <data name="CheatSheetSyntax" xml:space="preserve">
    <value>Syntax</value>
  </data>
  <data name="CheatSheetTab" xml:space="preserve">
    <value>Tab</value>
  </data>
  <data name="CheatSheetTabDetails" xml:space="preserve">
    <value>Stimmt mit einem TAB-Zeichen überein (Zeichencode 9).</value>
  </data>
  <data name="CheatSheetTitle" xml:space="preserve">
    <value>Spickzettel</value>
  </data>
  <data name="CheatSheetUnicodeCategory" xml:space="preserve">
    <value>Unicode-Kategorie</value>
  </data>
  <data name="CheatSheetUnicodeCategoryDetails" xml:space="preserve">
    <value>Stimmt mit einem Zeichen in der angegebenen Unicode-Kategorie überein. Beispielsweise stimmt \p{Ll} mit jedem Kleinbuchstaben überein.</value>
  </data>
  <data name="CheatSheetUnicodeEscape" xml:space="preserve">
    <value>Unicode-Maskierungszeichen</value>
  </data>
  <data name="CheatSheetUnicodeEscapeDetails" xml:space="preserve">
    <value>Unicode-Maskierungszeichen in der Form \x{FF}.</value>
  </data>
  <data name="CheatSheetUnicodeGrapheme" xml:space="preserve">
    <value>Unicode-Graphem</value>
  </data>
  <data name="CheatSheetUnicodeGraphemeDetails" xml:space="preserve">
    <value>Passt auf jedes einzelne Unicode-Graphem (d.h. Zeichen). Dazu gehören Zeilenumbrüche (unabhängig vom Allepunkten-Modus) und Grapheme, die als mehrere Codepunkte kodiert sind.</value>
  </data>
  <data name="CheatSheetUnicodeScript" xml:space="preserve">
    <value>Unicode-Skript</value>
  </data>
  <data name="CheatSheetUnicodeScriptDetails" xml:space="preserve">
    <value>Stimmt mit jedes Zeichen im angegebenen Unicode-Skript überein. Beispielsweise stimmt \p{Arabic} mit Zeichen in der arabischen Schrift überein.</value>
  </data>
  <data name="CheatSheetVerticalWhitespace" xml:space="preserve">
    <value>Vertikaler Leerraum</value>
  </data>
  <data name="CheatSheetVerticalWhitespaceDetails" xml:space="preserve">
    <value>Stimmt mit jedem vertikalen Leerraum überein (Zeilenumbrüche).</value>
  </data>
  <data name="CheatSheetWhitespace" xml:space="preserve">
    <value>Leerraum</value>
  </data>
  <data name="CheatSheetWhitespaceDetails" xml:space="preserve">
    <value>Stimmt mit jedem Leerraum überein (Leerzeichen, Tabulatoren, Zeilenumbrüche).</value>
  </data>
  <data name="CheatSheetWord" xml:space="preserve">
    <value>Wort</value>
  </data>
  <data name="CheatSheetWordBoundary" xml:space="preserve">
    <value>Wortgrenze</value>
  </data>
  <data name="CheatSheetWordBoundaryDetails" xml:space="preserve">
    <value>Entspricht einer Wortgrenzenposition zwischen einem Wortzeichen und einem Nicht-Wortzeichen oder einer Position (Anfang/Ende der Zeichenfolge). Weitere Informationen findest du in der Wortzeichenklasse (w).</value>
  </data>
  <data name="CheatSheetWordDetails" xml:space="preserve">
    <value>Stimmt mit jedem Wortzeichen überein(alphanumerisch &amp; Unterstrich). Stimmt nur mit Low-Ascii-Zeichen überein (keine akzentuierten oder nicht-romanischen Zeichen). Äquivalent zu [A-Za-z0-9_]</value>
  </data>
  <data name="Configuration" xml:space="preserve">
    <value>Konfiguration</value>
  </data>
  <data name="CultureInvariant" xml:space="preserve">
    <value>Kulturinvariant</value>
  </data>
  <data name="CultureInvariantDescription" xml:space="preserve">
    <value>Gibt an, dass kulturelle Unterschiede in der Sprache ignoriert werden.</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Reguläre Ausdrücke validieren und testen</value>
  </data>
  <data name="EcmaScript" xml:space="preserve">
    <value>ECMA-Skript</value>
  </data>
  <data name="EcmaScriptDescription" xml:space="preserve">
    <value>Aktiviert ECMASkript-kompatibles Verhalten für den Ausdruck. Dieser Wert kann nur in Verbindung mit den Optionen „Kulturinvariante“, „Groß-/Kleinschreibung ignorieren“ und „Mehrzeilig“ verwendet werden.</value>
  </data>
  <data name="IgnoreCase" xml:space="preserve">
    <value>Fall ignorieren</value>
  </data>
  <data name="IgnoreCaseDescription" xml:space="preserve">
    <value>Gibt die Übereinstimmung ohne Berücksichtigung der Groß-/Kleinschreibung an.</value>
  </data>
  <data name="IgnoreWhitespace" xml:space="preserve">
    <value>Leerraum ignorieren</value>
  </data>
  <data name="IgnoreWhitespaceDescription" xml:space="preserve">
    <value>Eliminiert Leerzeichen aus dem Muster und ermöglicht Kommentare, die mit # gekennzeichnet sind. Dieser Wert hat jedoch keinen Einfluss auf die Beseitigung von Leerzeichen in Zeichenklassen, numerischen Quantoren oder Token, die den Beginn einzelner Sprachelemente regulärer Ausdrücke markieren.</value>
  </data>
  <data name="LongDisplayTitle" xml:space="preserve">
    <value>Prüfer für reguläre Ausdrücke</value>
  </data>
  <data name="MatchGroupPrefix" xml:space="preserve">
    <value>Gruppe</value>
  </data>
  <data name="MatchInformation" xml:space="preserve">
    <value>Übereinstimmungs-Information</value>
  </data>
  <data name="MatchLocation" xml:space="preserve">
    <value>Standort</value>
  </data>
  <data name="MatchName" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="MatchNamePrefix" xml:space="preserve">
    <value>Übereinstimmen</value>
  </data>
  <data name="MatchValue" xml:space="preserve">
    <value>Wert</value>
  </data>
  <data name="Multiline" xml:space="preserve">
    <value>Mehrzeilig</value>
  </data>
  <data name="MultilineDescription" xml:space="preserve">
    <value>Ändert die Bedeutung von ^ und $, sodass sie am Anfang bzw. Ende einer beliebigen Zeile übereinstimmen und nicht nur am Anfang und Ende der gesamten Zeichenkette.</value>
  </data>
  <data name="Options" xml:space="preserve">
    <value>Optionen</value>
  </data>
  <data name="RegularExpression" xml:space="preserve">
    <value>Regulärer Ausdruck</value>
  </data>
  <data name="RightToLeft" xml:space="preserve">
    <value>Rechts nach links</value>
  </data>
  <data name="RightToLeftDescription" xml:space="preserve">
    <value>Gibt an, dass die Suche von rechts nach links statt von links nach rechts erfolgt.</value>
  </data>
  <data name="SearchKeywords" xml:space="preserve">
    <value>regulärer Ausdruck</value>
  </data>
  <data name="ShortDisplayTitle" xml:space="preserve">
    <value>RegEx</value>
  </data>
  <data name="Singleline" xml:space="preserve">
    <value>Einzelnezeile</value>
  </data>
  <data name="SinglelineDescription" xml:space="preserve">
    <value>Ändert die Bedeutung des Punktes (.), sodass er mit jedem Zeichen übereinstimmt (anstelle von jedem Zeichen außer \n).</value>
  </data>
  <data name="Text" xml:space="preserve">
    <value>Text</value>
  </data>
</root>